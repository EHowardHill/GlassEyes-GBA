ge_actions.cpp: 
#include "bn_log.h"
#include "bn_music.h"

#include "ge_globals.h"
#include "ge_sprites.h"
#include "ge_maps.h"
#include "ge_character_manager.h"
#include "ge_actions.h"

#include "ge_map_data.cpp"

static vector_2 previous_tile = {-1, -1};
static bool action_triggered = false;
static bool buffer_active = false;

int action_listener(map_manager *man, character_manager *ch_man)
{
    if (!ch_man->db.has_value())
    {
        auto chara_ptr = ch_man->player_ptr;
        vector_2 current_position = chara_ptr->v_sprite.bounds.position;

        // Calculate current tile coordinates
        vector_2 current_tile = {
            current_position.x / 32,
            current_position.y / 32};

        // Check if we've moved to a new tile
        bool new_tile = (previous_tile.x != current_tile.x ||
                         previous_tile.y != current_tile.y);

        // Get the action for current position
        int action = man->action(current_position);
        bool is_interactive_action = (action == CONVO_GARBAGE_SIGN01 ||
                                      action == CONVO_VISKER_SIGN ||
                                      action == CONVO_GARBAGE_03_SIGN ||
                                      action == CONVO_VISKER_AFTER_FIGHT ||
                                      action == CONVO_GARBAGE_04_SIGN ||
                                      action == CONVO_GARBAGE_05_SIGN ||
                                      action == LAB_COMPUTER);

        // Reset action_triggered flag when entering a new tile
        if (new_tile)
        {
            action_triggered = false;
            previous_tile = current_tile;

            if (action != 0 && !is_interactive_action)
            {
                global_data_ptr->action_iterations[action]++;
            }
        }

        if (is_interactive_action && keypad::a_pressed() && !buffer_active)
        {
            global_data_ptr->action_iterations[action]++;
            buffer_active = true;

            switch (action)
            {
            case CONVO_GARBAGE_SIGN01:
            {
                if (global_data_ptr->action_iterations[CONVO_GARBAGE_SIGN01] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_sign01);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[CONVO_GARBAGE_SIGN01] == 2)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_sign01b);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case CONVO_VISKER_SIGN:
            {
                ch_man->db.emplace();
                ch_man->db->load(&garbage_sign02);
                ch_man->db->init(ch_man);
                break;
            }
            case CONVO_GARBAGE_03_SIGN:
            {
                ch_man->db.emplace();
                ch_man->db->load(&garbage_sign03);
                ch_man->db->init(ch_man);
                break;
            }
            case CONVO_VISKER_AFTER_FIGHT:
            {
                ch_man->db.emplace();
                ch_man->db->load(&garbage_05b);
                ch_man->db->init(ch_man);
                break;
            }
            case CONVO_GARBAGE_04_SIGN:
            {
                ch_man->db.emplace();
                ch_man->db->load(&garbage_sign04);
                ch_man->db->init(ch_man);
                break;
            }
            case CONVO_GARBAGE_05_SIGN:
            {
                ch_man->db.emplace();
                ch_man->db->load(&garbage_sign05);
                ch_man->db->init(ch_man);
                break;
            }
            case LAB_COMPUTER:
            {
                if (global_data_ptr->action_iterations[LAB_COMPUTER] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_03);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[LAB_COMPUTER] == 2)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_03b);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[LAB_COMPUTER] == 3)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_03c);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[LAB_COMPUTER] == 4)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_03d);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[LAB_COMPUTER] == 5)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_03e);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[LAB_COMPUTER] == 6)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_03f);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            default:
            {
                break;
            }
            }
        }
        else if (action != 0 && !is_interactive_action && !action_triggered)
        {
            action_triggered = true; // Mark as triggered

            switch (action)
            {
            case CONVO_SCENE_1:
            {
                ch_man->db.emplace();
                ch_man->db->load(&test_convo);
                ch_man->db->init(ch_man);
                break;
            }
            case CONVO_GARBAGE_1:
            {
                if (global_data_ptr->action_iterations[CONVO_GARBAGE_1] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_01);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case CONVO_GARBAGE_2:
            {
                if (global_data_ptr->action_iterations[CONVO_GARBAGE_2] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_02);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case CONVO_GARBAGE_3:
            {
                if (global_data_ptr->action_iterations[CONVO_GARBAGE_3] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_03);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case TO_GARBAGE_02:
            {
                global_data_ptr->entry_map = &map_garbage_02;
                global_data_ptr->entry_position = {2, 6};
                return 1;
                break;
            }
            case TO_GARBAGE_02b:
            {
                global_data_ptr->entry_map = &map_garbage_02;
                global_data_ptr->entry_position = {13, 2};
                return 1;
                break;
            }
            case TO_VISKERS_HOUSE:
            {
                global_data_ptr->entry_map = &map_viskers_house;
                global_data_ptr->entry_position = {3, 5};
                return 1;
                break;
            }
            case CONVO_VISKER_BED:
            {
                if (global_data_ptr->action_iterations[CONVO_VISKER_BED] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&visker_h_03);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case CONVO_VISKER_FOOD:
            {
                if (global_data_ptr->action_iterations[CONVO_VISKER_FOOD] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&visker_h_01);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case CONVO_VISKER_NIGHTSTAND:
            {
                if (global_data_ptr->action_iterations[CONVO_VISKER_NIGHTSTAND] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&visker_h_02);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case TO_GARBAGE_03:
            {
                global_data_ptr->entry_map = &map_garbage_03;
                global_data_ptr->entry_position = {1, 3};
                return 1;
                break;
            }
            case CONVO_VISKER_FIGHT:
            {
                if (global_data_ptr->action_iterations[CONVO_VISKER_FIGHT] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_04);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[CONVO_VISKER_FIGHT] == 2)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_05);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case TO_GARBAGE_04:
            {
                global_data_ptr->entry_map = &map_garbage_04;
                global_data_ptr->entry_position = {29, 4};
                return 1;
                break;
            }
            case GARBAGE_04_EXIT_01:
            {
                if (global_data_ptr->action_iterations[CONVO_GARBAGE_04_SIGN] == 0)
                {
                    global_data_ptr->entry_map = &map_garbage_03;
                    global_data_ptr->entry_position = {2, 8};
                    return 1;
                }
                else
                {
                    global_data_ptr->entry_map = &map_garbage_05;
                    global_data_ptr->entry_position = {4, 45};
                    return 1;
                }
                break;
            }
            case GARBAGE_04_EXIT_02:
            {
                global_data_ptr->entry_map = &map_garbage_04;
                global_data_ptr->entry_position = {10, 12};
                return 1;
                break;
            }
            case GARBAGE_04_EXIT_03:
            {
                global_data_ptr->entry_map = &map_garbage_04;
                global_data_ptr->entry_position = {2, 20};
                return 1;
                break;
            }
            case GARBAGE_04_EXIT_04:
            {
                global_data_ptr->entry_map = &map_garbage_04;
                global_data_ptr->entry_position = {29, 12};
                return 1;
                break;
            }
            case GARBAGE_04_EXIT_05:
            {
                global_data_ptr->entry_map = &map_garbage_04;
                global_data_ptr->entry_position = {29, 20};
                return 1;
                break;
            }
            case EXIT_GARBAGE_01:
            {
                music::stop();
                break;
            }
            case CONVO_GARBAGE_FINAL_01:
            {
                if (global_data_ptr->action_iterations[CONVO_GARBAGE_FINAL_01] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_06);
                    ch_man->db->init(ch_man);
                }
                else
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&garbage_06b);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case CONVO_LAB_RUG:
            {
                if (global_data_ptr->action_iterations[CONVO_LAB_RUG] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_01);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case LAB_BED:
            {
                if (global_data_ptr->action_iterations[LAB_BED] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_02);
                    ch_man->db->init(ch_man);
                }
                else if (global_data_ptr->action_iterations[LAB_BED] == 2)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_02b);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case CONVO_LAB_GINGER:
            {
                if (global_data_ptr->action_iterations[CONVO_LAB_GINGER] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_05);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case LAB_DOOR:
            {
                if (global_data_ptr->action_iterations[LAB_DOOR] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_06);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case LAB_FRIDGE:
            {
                if (global_data_ptr->action_iterations[LAB_FRIDGE] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_07);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case LAB_LOCKER:
            {
                if (global_data_ptr->action_iterations[LAB_LOCKER] == 1)
                {
                    ch_man->db.emplace();
                    ch_man->db->load(&lab_08);
                    ch_man->db->init(ch_man);
                }
                break;
            }
            case TO_LAB_OUTSIDE:
            {
                ch_man->db.emplace();
                ch_man->db->load(&leaving_lab);
                ch_man->db->init(ch_man);
                break;
            }
            case ENTER_BG:
            {
                if (man->bg_ptr.has_value())
                {
                    man->bg_ptr.value().set_visible(true);
                }
                break;
            }
            case EXIT_BG:
            {
                if (man->bg_ptr.has_value())
                {
                    man->bg_ptr.value().set_visible(false);
                }
                break;
            }
            default:
            {
                break;
            }
            }
        }
        else
        {
            buffer_active = false;
        }
    }

    return NONE;
}

ge_battle.cpp: 
// ge_battle_optimized.cpp - Optimized version with ACT menu and DEFEND removed

#include "bn_core.h"
#include "bn_keypad.h"
#include "bn_music.h"
#include "bn_music_items.h"
#include "bn_sound_items.h"
#include "bn_random.h"

#include "bn_regular_bg_items_bg_battle_grid.h"
#include "bn_regular_bg_items_bg_dialogue_box.h"
#include "bn_sprite_items_spr_jeremy_01.h"
#include "bn_sprite_items_spr_visker_01.h"
#include "bn_sprite_items_hearts.h"
#include "bn_sprite_items_battle_icons.h"
#include "bn_sprite_items_battle_chars.h"
#include "bn_sprite_items_battle_squares.h"

#include "ge_character_manager.h"
#include "ge_actions.h"
#include "ge_battle.h"
#include "ge_bullet.h"

using namespace bn;

// Jeremy frame indices
static constexpr int JEREMY_IDLE_FRAME = 10;
static constexpr int JEREMY_HURT_START = 11; // 11..14 inclusive
static constexpr int JEREMY_HURT_END = 14;

// NEW: attack animation range 15..21 inclusive
static constexpr int JEREMY_ATK_START = 15;
static constexpr int JEREMY_ATK_END = 21;

struct battle_state
{
    int party_size = 1;
    int current_actor = -1;
    int selected_menu = STATUS_BAR_NONE;
    int stage = stage_talking;
    int result = RESULT_FIRST;
    int y_delta = 0;

    // Reusable dialogue state
    conversation *active_conv = nullptr;
    int dlg_index = 0;
    int dlg_size = 0;
    int dlg_ticker = 0;
    text dlg_lines[3] = {{nullptr, {-40, 32}}, {nullptr, {-40, 48}}, {nullptr, {-40, 64}}};
    optional<sprite_ptr> portrait;
    optional<regular_bg_ptr> bg_ptr;

    // Combat entities
    optional<sprite_ptr> player_sprite;
    optional<sprite_ptr> enemy_sprite;
    int player_state = 0;
    int enemy_state = 0;
    int player_ticker = 0;
    int enemy_ticker = 0;

    // Menu state
    int menu_index = 0;

    // Attack bar
    optional<sprite_ptr> attack_header;
    optional<sprite_ptr> attack_recv;
    optional<sprite_ptr> attack_unit;

    // Recv state
    optional<sprite_ptr> heart;
    vector_2 heart_pos = {0, 0};
    int recv_ticker = 0;
    vector<bullet, 16> bullets;

    // UI elements
    optional<sprite_ptr> char_img;
    optional<sprite_ptr> battle_icons[3]; // Reduced from 4 to 3 (no DEFEND)
    optional<text> labels[5];
};

// Helper functions
static bool is_alive(int idx, battle_state *bs)
{
    return idx >= 0 && idx < bs->party_size && global_data_ptr->hp[idx] > 0;
}

static int next_living(int from, battle_state *bs)
{
    for (int i = 1; i <= bs->party_size; ++i)
    {
        int idx = (from + i) % bs->party_size;
        if (is_alive(idx, bs))
            return idx;
    }
    return -1;
}

static int random_living(battle_state *bs)
{
    int cnt = 0, alive[4];
    for (int i = 0; i < bs->party_size; ++i)
    {
        if (is_alive(i, bs))
            alive[cnt++] = i;
    }
    return cnt > 0 ? alive[global_data_ptr->bn_random.get_int(0, cnt)] : -1;
}

static const char *get_name(int i)
{
    const char *names[] = {"JEREMY", "GINGER", "SEBELLUS", "VISTA"};
    return i < 4 ? names[i] : "ALLY";
}

// Dialogue functions
static void init_dialogue(conversation *conv, battle_state *bs)
{
    if (!bs->bg_ptr)
    {
        bs->bg_ptr = regular_bg_items::bg_dialogue_box.create_bg(0, 0);
    }

    bs->active_conv = conv;
    bs->dlg_index = 0;
    bs->dlg_size = 0;
    bs->dlg_ticker = 0;

    // Count lines
    for (int i = 0; i < 64 && (*conv)[i].action != ACT_END; ++i)
    {
        bs->dlg_size++;
    }

    if (bs->dlg_size > 0)
    {
        const auto &line = (*conv)[0];
        if (line.portrait)
        {
            bs->portrait = line.portrait->create_sprite(-84, 56, line.emotion);
        }

        for (int i = 0; i < 3; ++i)
        {
            bs->dlg_lines[i].init(line.raw_text[i]);
            bs->dlg_lines[i].size = line.size;
        }
    }
}

static void update_dialogue(battle_state *bs)
{
    if (!bs->active_conv || bs->dlg_index >= bs->dlg_size)
        return;

    const auto &line = (*bs->active_conv)[bs->dlg_index];

    // Update portrait animation
    if (bs->portrait && line.portrait)
    {
        bs->portrait->set_tiles(line.portrait->tiles_item(),
                                (line.emotion * 2) + (bs->dlg_ticker % 12 < 6));
    }

    // Update text
    if (bs->dlg_ticker % 3 == 0)
    {
        for (int i = 0; i < 3; ++i)
        {
            if (!bs->dlg_lines[i].is_ended())
            {
                bs->dlg_lines[i].update(line.portrait, false);
                break;
            }
        }
    }

    // Update letter effects
    for (int i = 0; i < 3; ++i)
    {
        for (auto &letter : bs->dlg_lines[i].letters)
        {
            letter.update(line.shake, line.size);
        }
    }

    bs->dlg_ticker++;
}

static bool advance_dialogue(battle_state *bs)
{
    if (bs->dlg_index < bs->dlg_size - 1)
    {
        bs->dlg_index++;
        bs->dlg_ticker = 0;

        const auto &line = (*bs->active_conv)[bs->dlg_index];

        if (line.portrait)
        {
            bs->portrait = line.portrait->create_sprite(-84, 56, line.emotion);
        }
        else
        {
            bs->portrait.reset();
        }

        for (int i = 0; i < 3; ++i)
        {
            bs->dlg_lines[i].init(line.raw_text[i]);
            bs->dlg_lines[i].size = line.size;
        }
        return true;
    }
    return false;
}

static void clear_dialogue(battle_state *bs)
{
    bs->bg_ptr.reset();
    bs->portrait.reset();
    bs->active_conv = nullptr;
    bs->dlg_ticker = 0;
    for (int i = 0; i < 3; ++i)
    {
        bs->dlg_lines[i].letters.clear();
        bs->dlg_lines[i].index = 0;
        bs->dlg_lines[i].size = 0;
    }
}

static bool is_dialogue_active(battle_state *bs)
{
    return bs->active_conv && bs->dlg_index < bs->dlg_size;
}

static bool are_lines_complete(battle_state *bs)
{
    return bs->dlg_lines[0].is_ended() &&
           bs->dlg_lines[1].is_ended() &&
           bs->dlg_lines[2].is_ended();
}

// Main battle function
int battle_map()
{
    music::stop();
    music_items::boss.play();
    sound_items::snd_fight_start.play();

    auto bg_grid = regular_bg_items::bg_battle_grid.create_bg(0, 0);

    // Create and reset battle state
    battle_state bs;

    // Initialize sprites
    bs.player_sprite = sprite_items::jeremy_battle_intro.create_sprite(-96, 16, 0);
    bs.enemy_sprite = sprite_items::visker_battle_intro.create_sprite(96, 16, 0);
    bs.heart = sprite_items::hearts.create_sprite(0, 0, 1);

    // Setup conversations based on foe
    vector<conversation *, 3> convos[RESULT_SIZE];
    vector<conversation *, 3> spare_convos;

    switch (global_data_ptr->battle_foe)
    {
    case FOE_VISKERS_01:
        global_data_ptr->enemy_max_hp[0] = 12;
        global_data_ptr->enemy_hp[0] = 12;
        global_data_ptr->enemy_allowed_moveset = 3;

        convos[RESULT_FIRST].push_back(&garbage_fight_01);
        convos[RESULT_UP].push_back(&garbage_fight_02);
        convos[RESULT_UP].push_back(&garbage_fight_03);
        convos[RESULT_LAST_WIN].push_back(&garbage_fight_04);

        spare_convos.push_back(&garbage_fight_02);
        spare_convos.push_back(&garbage_fight_03);
        spare_convos.push_back(&garbage_fight_04);
        break;

    case FOE_VISKERS_02:
        global_data_ptr->enemy_max_hp[0] = 99;
        global_data_ptr->enemy_hp[0] = 99;
        global_data_ptr->enemy_allowed_moveset = BULLET_SIZE;

        convos[RESULT_FIRST].push_back(&garbage_fight_05);
        break;

    default:
        break;
    }

    // Main game loop
    while (true)
    {
        bg_grid.set_position(bg_grid.x() - 1, bg_grid.y() - 1);

        int y_offset = 16 + bs.y_delta;
        switch (bs.player_state)
        {
        case 0:
        {
            if (bs.player_ticker < 55)
            {
                bs.player_sprite->set_tiles(sprite_items::jeremy_battle_intro.tiles_item(), bs.player_ticker / 5);
                bs.player_ticker++;
            }
            else
            {
                bs.player_state = 1; // go idle after intro
                bs.player_ticker = 0;
                bs.player_sprite->set_tiles(sprite_items::jeremy_battle_intro.tiles_item(), JEREMY_IDLE_FRAME);
            }
            break;
        }

        case 1: // IDLE
            bs.player_sprite->set_tiles(sprite_items::jeremy_battle_intro.tiles_item(),
                                        JEREMY_IDLE_FRAME);
            break;

        case 2: // HURT (11..14 once, then idle 10)
        {
            constexpr int TICKS_PER_FRAME = 4;
            int anim_frame_idx = bs.player_ticker / TICKS_PER_FRAME;
            int frame = JEREMY_HURT_START + anim_frame_idx;

            if (frame > JEREMY_HURT_END)
            {
                bs.player_state = 1;
                bs.player_ticker = 0;
                bs.player_sprite->set_tiles(sprite_items::jeremy_battle_intro.tiles_item(),
                                            JEREMY_IDLE_FRAME);
            }
            else
            {
                bs.player_sprite->set_tiles(sprite_items::jeremy_battle_intro.tiles_item(), frame);
                bs.player_ticker++;
            }
        }
        break;

        case 3: // NEW: ATTACK_ANIM (15..21 once, then idle 10)
        {
            constexpr int TICKS_PER_FRAME = 3; // tweak feel/speed as desired
            int anim_frame_idx = bs.player_ticker / TICKS_PER_FRAME;
            int frame = JEREMY_ATK_START + anim_frame_idx;

            if (frame > JEREMY_ATK_END)
            {
                bs.player_state = 1;
                bs.player_ticker = 0;
                bs.player_sprite->set_tiles(sprite_items::jeremy_battle_intro.tiles_item(),
                                            JEREMY_IDLE_FRAME);
            }
            else
            {
                bs.player_sprite->set_tiles(sprite_items::jeremy_battle_intro.tiles_item(), frame);
                bs.player_ticker++;
            }
        }
        break;

        default:
            break;
        }

        bs.player_sprite->set_position(-96, y_offset);

        // Update enemy animation
        switch (bs.enemy_state)
        {
        case 0: // INTRO
            if (bs.enemy_ticker < 35)
            {
                bs.enemy_sprite->set_tiles(sprite_items::visker_battle_intro.tiles_item(),
                                           bs.enemy_ticker / 5);
                bs.enemy_ticker++;
            }
            else
            {
                bs.enemy_state = 1;
            }
            break;

        case 1: // IDLE
            bs.enemy_sprite->set_tiles(sprite_items::visker_battle_intro.tiles_item(),
                                       ((bs.enemy_ticker / 5) % 4) + 6);
            bs.enemy_ticker++;
            break;

        case 2: // ATTACK
            bs.enemy_sprite->set_tiles(sprite_items::visker_battle_intro.tiles_item(),
                                       ((bs.enemy_ticker / 5) % 6) + 10);
            bs.enemy_ticker++;
            break;

        default:
            break;
        }
        bs.enemy_sprite->set_position(96, y_offset);

        // Y offset for dialogue
        bs.y_delta += is_dialogue_active(&bs) ? (bs.y_delta > -32 ? -4 : 0) : (bs.y_delta < 0 ? 4 : 0);

        // Stage: Talking
        if (bs.stage == stage_talking)
        {
            if (global_data_ptr->enemy_hp[0] <= 0)
            {
                bs.result = RESULT_LAST_WIN;
            }

            if (!is_dialogue_active(&bs))
            {
                if (bs.result < RESULT_SIZE && convos[bs.result].size() > 0)
                {
                    conversation *c = convos[bs.result].front();
                    convos[bs.result].erase(convos[bs.result].begin());
                    init_dialogue(c, &bs);
                }
                else
                {
                    bs.stage = stage_recv;
                }
            }
            else
            {
                update_dialogue(&bs);

                if (keypad::a_pressed() && are_lines_complete(&bs))
                {
                    if (!advance_dialogue(&bs))
                    {
                        clear_dialogue(&bs);
                    }
                }
            }
        }

        // Stage: Recv (enemy turn)
        else if (bs.stage == stage_recv)
        {
            bs.bg_ptr = regular_bg_items::bg_battle_box.create_bg(0, 0);

            if (!bs.heart.has_value())
                bs.heart = sprite_items::hearts.create_sprite(0, 0, 1);

            if (bs.recv_ticker == 0)
            {
                bs.enemy_state = 2;
                bs.enemy_ticker = 0;
                int type = global_data_ptr->bn_random.get_int(0, global_data_ptr->enemy_allowed_moveset);
                bullet::populate(&bs.bullets, type);
            }

            if (next_living(-1, &bs) < 0 || global_data_ptr->enemy_hp[0] <= 0)
            {
                music::stop();
                text::toasts.clear();
                return CONTINUE;
            }

            // Initialize bullets if needed
            if (bs.recv_ticker == 0)
            {
                int type = global_data_ptr->bn_random.get_int(0, global_data_ptr->enemy_allowed_moveset);
                bullet::populate(&bs.bullets, type);
            }

            // Update heart position
            bs.heart_pos.x += keypad::right_held() - keypad::left_held();
            bs.heart_pos.y += keypad::down_held() - keypad::up_held();

            // Clamp positions
            if (bs.heart_pos.x < -48)
                bs.heart_pos.x = -48;
            if (bs.heart_pos.x > 48)
                bs.heart_pos.x = 48;
            if (bs.heart_pos.y < -48)
                bs.heart_pos.y = -48;
            if (bs.heart_pos.y > 48)
                bs.heart_pos.y = 48;

            bs.heart->set_position(bs.heart_pos.x, bs.heart_pos.y);
            // Always use normal heart sprite (no defense variation)
            bs.heart->set_tiles(sprite_items::hearts.tiles_item(), 1);

            // Update bullets
            for (auto &b : bs.bullets)
            {
                b.update();

                if (b.item && b.item->visible())
                {
                    if (abs(bs.heart_pos.x - b.item->x()) + abs(bs.heart_pos.y - b.item->y()) < 12)
                    {
                        int who = random_living(&bs);
                        if (who >= 0)
                        {
                            global_data_ptr->hp[who] -= 2;
                            text::add_toast(-2, {-96, -36});
                            sound_items::sfx_damage.play();

                            // If Jeremy took the hit, play hurt animation
                            if (who == 0)
                            {
                                bs.player_state = 2;  // HURT
                                bs.player_ticker = 0; // restart the hurt anim
                            }
                        }
                        b.item->set_visible(false);
                    }
                }
            }

            if (++bs.recv_ticker > 250)
            {
                bs.recv_ticker = 0;
                bs.current_actor = -1;
                bs.stage = stage_status;
            }
        }

        // Stage: Status (player menu)
        else if (bs.stage == stage_status)
        {
            bs.bg_ptr.reset();
            bs.enemy_state = 1; // stay in idle
            bs.heart.reset();
            bs.bullets.clear();

            if (next_living(-1, &bs) < 0)
            {
                music::stop();
                text::toasts.clear();
                return CONTINUE;
            }

            // Get next actor if needed
            if (!bs.char_img)
            {
                int next = next_living(bs.current_actor, &bs);
                if (next < 0)
                {
                    // All characters have acted, go to talking stage
                    bs.stage = stage_talking;
                    continue;
                }

                bs.current_actor = next;
                bs.char_img = sprite_items::battle_chars.create_sprite(-42, -42, next);

                // Setup labels
                string<20> hp_str = "HP:";
                hp_str.push_back('0' + global_data_ptr->hp[next] / 10);
                hp_str.push_back('0' + global_data_ptr->hp[next] % 10);
                hp_str.push_back('/');
                hp_str.push_back('0' + global_data_ptr->max_hp[next] / 10);
                hp_str.push_back('0' + global_data_ptr->max_hp[next] % 10);

                bs.labels[0] = {get_name(next), {0, -52}};
                bs.labels[1] = {hp_str, {0, -36}};
                bs.labels[0]->render();
                bs.labels[1]->render();

                // Setup main menu (without ACT and DEFEND)
                bs.menu_index = 0;
                bs.selected_menu = STATUS_BAR_NONE;

                // Create 3 menu icons: ATTACK, ITEM, SPARE
                int icon_indices[] = {0, 2, 3}; // Skip index 1 (ACT) and 4 (DEFEND)
                for (int i = 0; i < 3; ++i)
                {
                    bs.battle_icons[i] = sprite_items::battle_icons.create_sprite(-22, -12 + (18 * i), icon_indices[i]);
                }

                const char *menu_labels[] = {"ATTACK", "ITEM", "SPARE"};
                bs.labels[2] = {menu_labels[0], {0, -12}};
                bs.labels[2]->render();
            }

            // Handle menu selection
            if (bs.selected_menu == STATUS_BAR_NONE)
            {
                if (keypad::up_pressed())
                {
                    bs.menu_index = (bs.menu_index + 2) % 3; // Changed from 4 to 3
                    sound_items::snd_dialogue_generic.play();
                }
                else if (keypad::down_pressed())
                {
                    bs.menu_index = (bs.menu_index + 1) % 3; // Changed from 4 to 3
                    sound_items::snd_dialogue_generic.play();
                }
                else if (keypad::a_pressed())
                {
                    sound_items::snd_alert.play();
                    // Map menu index to status bar values
                    switch (bs.menu_index)
                    {
                    case 0:
                        bs.selected_menu = STATUS_BAR_ATTACK;
                        break;
                    case 1:
                        bs.selected_menu = STATUS_BAR_ITEM;
                        break;
                    case 2:
                        bs.selected_menu = STATUS_BAR_SPARE;
                        break;
                    }
                }

                // Update label
                const char *menu_labels[] = {"ATTACK", "ITEM", "SPARE"};
                bs.labels[2].reset();
                bs.labels[2] = {menu_labels[bs.menu_index], {0, -12 + (18 * bs.menu_index)}};
                bs.labels[2]->render();
            }

            // Handle menu selections
            else if (bs.selected_menu == STATUS_BAR_ATTACK)
            {
                bs.char_img.reset();
                for (int i = 0; i < 5; ++i)
                {
                    bs.labels[i].reset();
                }
                for (int i = 0; i < 3; ++i)
                {
                    bs.battle_icons[i].reset();
                }
                bs.stage = stage_attack;
            }
            else if (bs.selected_menu == STATUS_BAR_SPARE)
            {
                if (spare_convos.size() > 0)
                {
                    conversation *spare_conv = spare_convos.front();
                    spare_convos.erase(spare_convos.begin());
                    init_dialogue(spare_conv, &bs);

                    bs.char_img.reset();
                    for (int i = 0; i < 5; ++i)
                    {
                        bs.labels[i].reset();
                    }
                    for (int i = 0; i < 3; ++i)
                    {
                        bs.battle_icons[i].reset();
                    }

                    bs.stage = stage_talking;
                }
                else
                {
                    // No spare conversations left, just reset menu selection
                    bs.selected_menu = STATUS_BAR_NONE;
                }
            }
            else if (bs.selected_menu == STATUS_BAR_ITEM)
            {
                // Hide the scrolling selector label ("ITEM"/"ITEMS") while in the ITEM screen
                if (bs.labels[2])
                    bs.labels[2].reset();

                // Remove the menu icons while viewing items
                for (int i = 0; i < 3; ++i)
                    bs.battle_icons[i].reset();

                // Show placeholder
                bs.labels[3].reset();
                bs.labels[3] = {"* No Items", {-22, -12}};
                bs.labels[3]->render();

                // Back out of ITEM screen
                if (keypad::b_pressed())
                {
                    sound_items::snd_alert.play();

                    // Clear the placeholder so it doesn't persist
                    if (bs.labels[3])
                        bs.labels[3].reset();

                    bs.selected_menu = STATUS_BAR_NONE;

                    // Restore menu icons
                    int icon_indices[] = {0, 2, 3};
                    for (int i = 0; i < 3; ++i)
                        bs.battle_icons[i] = sprite_items::battle_icons.create_sprite(-22, -12 + (18 * i), icon_indices[i]);

                    // Optionally force the selector label to reappear immediately this frame
                    // (Otherwise the STATUS_BAR_NONE branch will recreate it on the next tick)
                    const char *menu_labels[] = {"ATTACK", "ITEM", "SPARE"};
                    bs.labels[2] = {menu_labels[bs.menu_index], {0, -12 + (18 * bs.menu_index)}};
                    bs.labels[2]->render();
                }
            }
        }

        // Stage: Attack
        else if (bs.stage == stage_attack)
        {
            if (!bs.attack_header)
            {
                bs.attack_header = sprite_items::battle_chars.create_sprite(-42, 0, 0);
                bs.attack_recv = sprite_items::battle_squares.create_sprite(-10, 0, 0);
                bs.attack_unit = sprite_items::battle_squares.create_sprite(64, 0, 2);
            }

            bs.attack_unit->set_x(bs.attack_unit->x() - 1.2);

            if (keypad::a_pressed())
            {
                // START ATTACK ANIMATION NOW
                bs.player_state = 3; // ATTACK_ANIM
                bs.player_ticker = 0;

                int dist = abs(bs.attack_unit->x().integer() - bs.attack_recv->x().integer());
                if (dist < 5)
                {
                    global_data_ptr->enemy_hp[0] -= (5 - dist);
                    text::add_toast(-(5 - dist), {96, -36});
                }
                sound_items::snd_alert.play();

                bs.attack_header.reset();
                bs.attack_recv.reset();
                bs.attack_unit.reset();
                bs.stage = stage_talking; // animation continues while we transition
            }
            else if (bs.attack_unit->x() <= -42)
            {
                bs.attack_header.reset();
                bs.attack_recv.reset();
                bs.attack_unit.reset();
                bs.stage = stage_talking;
            }
        }

        text::update_toasts();
        core::update();
    }
}

ge_bullet.cpp: 
// ge_bullet.cpp - Optimized implementation
#include "ge_bullet.h"
#include "ge_globals.h"
#include "bn_sprite_items_hearts.h"
#include "bn_math.h"

using namespace bn;

// Pre-computed patterns in ROM (no RAM usage)
// Order must match BULLET_ANIM_TYPES enum
const bullet_pattern PATTERNS[BULLET_SIZE] = {
    // vx    vy   amp  per  acc  flags
    { 0,  2,   0,   0,   0,  0x00}, // BULLET_FALL
    { 0, -4,   0,   0,   0,  0x00}, // BULLET_RISE
    { 0,  24,  28,  20,   0,  0x01}, // BULLET_ZIGZAG - flag 0x01 = use zigzag
    { 0,  20,  40,  36,   0,  0x02}, // BULLET_WAVE - flag 0x02 = use wave
    { 0,   5,   0,   0,  10,  0x04}, // BULLET_ACCEL - flag 0x04 = accelerate
    {32,  22,   0,   0,   0,  0x08}, // BULLET_BOUNCE - flag 0x08 = bounce
    {12,  12,   0,   0,   0,  0x10}, // BULLET_HOMING - flag 0x10 = home
    { 0,  19,  30,  64,   0,  0x20}, // BULLET_ORBIT - flag 0x20 = orbit (amp=radius)
    { 0,  16,  45,  64,  -3,  0x40}, // BULLET_SPIRAL - flag 0x40 = spiral (acc=drift)
};

// Simple sine approximation table (64 entries = full period)
const int8_t SINE_TABLE[64] = {
    0, 6, 12, 18, 24, 30, 35, 40, 45, 49, 53, 56, 59, 61, 63, 64,
    64, 64, 63, 61, 59, 56, 53, 49, 45, 40, 35, 30, 24, 18, 12, 6,
    0, -6, -12, -18, -24, -30, -35, -40, -45, -49, -53, -56, -59, -61, -63, -64,
    -64, -64, -63, -61, -59, -56, -53, -49, -45, -40, -35, -30, -24, -18, -12, -6
};

bullet::bullet(int16_t x_pos, int16_t y_pos, uint8_t anim_type)
{
    compact.x = x_pos;
    compact.y = y_pos;
    compact.ticker = 0;
    compact.type = anim_type;
    compact.state1 = 0;
    compact.state2 = 0;
    
    // Create sprite at actual position
    item = sprite_items::hearts.create_sprite(
        fixed(x_pos) / 4, 
        fixed(y_pos) / 4, 
        4
    );
    
    // Initialize type-specific state
    switch(anim_type)
    {
    case BULLET_ZIGZAG:
        compact.state1 = (global_data_ptr->bn_random.get_int(2) ? 1 : -1); // direction
        break;
    case BULLET_BOUNCE:
        compact.state1 = (global_data_ptr->bn_random.get_int(2) ? 1 : -1); // x direction
        break;
    case BULLET_ORBIT:
    case BULLET_SPIRAL:
        compact.state1 = global_data_ptr->bn_random.get_int(64); // starting angle
        compact.state2 = PATTERNS[anim_type].amplitude; // radius
        break;
    default:
        break;
    }
}

void bullet::update()
{
    if (!item.has_value()) return;
    
    const bullet_pattern& pattern = PATTERNS[compact.type];
    
    // Get current position
    int16_t x = compact.x;
    int16_t y = compact.y;
    
    // Apply movement based on type
    uint8_t flags = pattern.flags;
    
    if (flags & 0x01) // ZIGZAG
    {
        // Sharp zigzag movement
        x += compact.state1 * 14; // Move horizontally
        
        // Check bounds and flip direction (using amplitude as bound)
        int16_t bound = pattern.amplitude * 4; // Convert to our scale
        if (abs(x) > bound) {
            x = (x > 0) ? bound : -bound;
            compact.state1 = -compact.state1;
        }
        y += pattern.vy_base;
    }
    else if (flags & 0x02) // WAVE
    {
        // Use sine table for smooth wave
        uint8_t phase = (compact.ticker * 64) / pattern.period;
        int8_t sine = SINE_TABLE[phase & 63];
        x = compact.x + (sine * pattern.amplitude) / 32; // Scale sine to amplitude
        y += pattern.vy_base;
    }
    else if (flags & 0x04) // ACCEL
    {
        // Accelerating bullet
        int16_t current_vy = pattern.vy_base + (compact.ticker * pattern.accel) / 128;
        if (current_vy > 56) current_vy = 56; // Max speed cap
        y += current_vy;
    }
    else if (flags & 0x08) // BOUNCE
    {
        // Bouncing movement
        x += pattern.vx_base * compact.state1;
        y += pattern.vy_base;
        
        // Bounce off walls (character box bounds)
        if (x < -240 || x > 240) { // -60 to 60 in normal coords
            compact.state1 = -compact.state1;
            x = (x < 0) ? -240 : 240;
        }
    }
    else if (flags & 0x10) // HOMING
    {
        // Simplified homing - just move toward player position
        // Assume player is at (0, 0) or get from global
        int16_t dx = -x / 16; // Simple proportional control
        int16_t dy = -y / 16;
        
        // Add to base velocity
        x += pattern.vx_base + dx;
        y += pattern.vy_base + dy;
    }
    else if (flags & 0x20) // ORBIT
    {
        // Use sine/cosine table for circular motion
        uint8_t angle = compact.state1;
        int8_t cos_val = SINE_TABLE[(angle + 16) & 63]; // cos is sine shifted by 90Â°
        int8_t sin_val = SINE_TABLE[angle & 63];
        
        // Update angle for next frame
        compact.state1 = (angle + 2) & 63; // Rotate ~5.6 degrees per frame
        
        // Calculate position from center
        x = (compact.state2 * cos_val) / 32;
        y = (compact.state2 * sin_val) / 32 + compact.y + pattern.vy_base;
    }
    else if (flags & 0x40) // SPIRAL
    {
        // Similar to orbit but with shrinking radius
        uint8_t angle = compact.state1;
        int8_t cos_val = SINE_TABLE[(angle + 16) & 63];
        int8_t sin_val = SINE_TABLE[angle & 63];
        
        // Update angle and radius
        compact.state1 = (angle + 3) & 63; // Faster rotation
        if (compact.state2 > 8) {
            compact.state2 += pattern.accel; // accel is negative for inward spiral
        }
        
        x = (compact.state2 * cos_val) / 32;
        y = (compact.state2 * sin_val) / 32 + compact.y + pattern.vy_base;
    }
    else // FALL, RISE, or default
    {
        // Simple linear movement
        x += pattern.vx_base;
        y += pattern.vy_base;
    }
    
    // Update stored position
    compact.x = x;
    compact.y = y;
    compact.ticker++;
    
    // Update sprite position
    item.value().set_position(fixed(x) / 4, fixed(y) / 4);
}

void bullet::populate(bn::vector<bullet, bullet_count>* bullets, int anim_type)
{
    bullets->clear();
    
    for (int b = 0; b < bullet_count; b++)
    {
        // Starting positions in our compact format (x4 scale)
        int16_t x = (global_data_ptr->bn_random.get_int(-60, 60)) * 4;
        int16_t y = (-70 - (b * 15)) * 4; // Spread them out vertically
        
        // Adjust starting position based on type
        switch(anim_type)
        {
        case BULLET_RISE:
            y = (70 + (b * 16)) * 4;
            break;
        case BULLET_HOMING:
            // Start from edges
            if (b % 2) x = (b % 4 < 2) ? -240 : 240;
            break;
        default:
            break;
        }
        
        bullet nb(x, y, anim_type);
        
        // Add some variation
        if (anim_type == BULLET_ZIGZAG || anim_type == BULLET_WAVE) {
            nb.compact.state2 = 15 + global_data_ptr->bn_random.get_int(30); // Vary amplitude
        }
        
        bullets->push_back(nb);
    }
}

ge_character_manager.cpp: 
#include "bn_log.h"
#include "bn_list.h"
#include "bn_unique_ptr.h"
#include "bn_optional.h"
#include "bn_music.h"
#include "bn_sound_items.h"

#include "ge_sprites.h"
#include "ge_text.h"
#include "ge_character_manager.h"
#include "ge_maps.h"
#include "ge_globals.h"

#include "bn_sprite_items_hearts.h"

using namespace bn;

// Implementation in ge_character_manager.cpp
character_manager::character_manager() : player_ptr(nullptr)
{
}

character *character_manager::add_character(int index, vector_2 position)
{
    if (characters.size() >= 64)
        return nullptr;

    // Create new character
    characters.push_back(make_unique<character>(index, position));
    character *new_char = characters.back().get();

    if (global_data_ptr->process_stage != GARBAGE_TO_BLACK)
    {
        if (index == CHAR_GINGER)
        {
            new_char->is_follow = true;
        }
    }

    // Track player
    if (new_char->type() == CH_TYPE_PLAYER && !player_ptr)
    {
        player_ptr = new_char;
    }

    return new_char;
}

bool character_manager::remove_character(character *ch)
{
    if (!ch || ch == player_ptr)
        return false; // Don't remove player

    for (auto it = characters.begin(); it != characters.end(); ++it)
    {
        if (it->get() == ch)
        {
            characters.erase(it);
            return true;
        }
    }
    return false;
}

void character_manager::clear_npcs()
{
    auto it = characters.begin();
    while (it != characters.end())
    {
        if ((*it)->type() == CH_TYPE_NPC)
        {
            it = characters.erase(it);
        }
        else
        {
            ++it;
        }
    }
}

character *character_manager::find_at_position(vector_2 pos, int tolerance)
{
    for (auto &ch : characters)
    {
        if (ch)
        {
            int dx = abs(ch->v_sprite.bounds.position.x.integer() - pos.x.integer());
            int dy = abs(ch->v_sprite.bounds.position.y.integer() - pos.y.integer());

            if (dx <= tolerance && dy <= tolerance)
            {
                return ch.get();
            }
        }
    }
    return nullptr;
}

character *character_manager::find_by_index(int index)
{
    for (auto &ch : characters)
    {
        if (ch && ch->index == index)
        {
            return ch.get();
        }
    }
    return nullptr;
}

void character_manager::alert()
{
    vector_2 player_pos = player_ptr->v_sprite.real_position().position;

    sprite_ptr alert_box = sprite_items::hearts.create_sprite(player_pos.x, player_pos.y - 48, 0);
    music::stop();
    sound_items::snd_alert.play();

    for (int t = 0; t < 64; t++)
    {
        core::update();
    }

    global_data_ptr->entry_position_raw = player_pos;
    global_data_ptr->entry_direction = player_ptr->face;
    status = BATTLE;
}

void character_manager::update(map_manager *current_map = nullptr)
{
    bool db_inactive = true;

    // Handle dialogue box
    if (db.has_value())
    {
        db_inactive = db.value().is_ended();
        db.value().update();

        if (keypad::a_pressed())
        {
            db.value().handle_a_button_press(this);
        }
        else if (keypad::b_pressed())
        {
            db.value().index++;
            db.value().init(this);
            // Only render lines that have been properly initialized
            if (!db.value().lines[0].reference.empty())
                db.value().lines[0].render();
            if (!db.value().lines[1].reference.empty())
                db.value().lines[1].render();
            if (!db.value().lines[2].reference.empty())
                db.value().lines[2].render();
        }

        if (db.value().is_ended())
        {
            db.reset();
        }
    }

    // Handle characters
    for (auto &ch : characters)
    {
        if (ch)
        {
            ch->update(current_map, db_inactive);

            if (ch->is_follow)
            {
                auto f_ch = find_by_index(ch->follow_id);
                vector_2 f_pos = {f_ch->v_sprite.bounds.position.x / 32, f_ch->v_sprite.bounds.position.y / 32};

                switch (f_ch->face)
                {
                case DIR_UP:
                {
                    ch->move_to = {f_pos.x.integer(), f_pos.y.integer() + 1};
                    break;
                }
                case DIR_DOWN:
                {
                    ch->move_to = {f_pos.x.integer(), f_pos.y.integer() - 1};
                    break;
                }
                case DIR_LEFT:
                {
                    ch->move_to = {f_pos.x.integer() + 1, f_pos.y.integer()};
                    break;
                }
                case DIR_RIGHT:
                {
                    ch->move_to = {f_pos.x.integer() - 1, f_pos.y.integer()};
                    break;
                }
                default:
                {
                    break;
                }
                }
            }
        }
    }
}

ge_globals.cpp: 
// ge_globals.cpp

#include "ge_globals.h"

// Definition of the global pointer - this should only exist in one source file
global_data *global_data_ptr = nullptr;

ge_maps.cpp: 
// ge_maps.cpp

#include "bn_log.h"
#include "bn_regular_bg_ptr.h"

#include "ge_globals.h"
#include "ge_maps.h"
#include "ge_sprites.h"
#include "ge_character_manager.h"

map_manager::map_manager(const map *current_map_)
    : current_map(current_map_)
{
    if (global_data_ptr->bg != nullptr)
    {
        bg_ptr = global_data_ptr->bg->create_bg(0, 0);
        bg_ptr.value().set_visible(false);
    }

    collider_ptr = current_map_->bg_item_ptr->create_bg(0, 0);
}

void map_manager::update()
{
    vector_2 *cam = &v_sprite_ptr::camera;

    vector_2 offset = {
        current_map->raw_size.x / 2,
        current_map->raw_size.y / 2};

    collider_ptr.value().set_position(-cam->x + offset.x, -cam->y + offset.y);
}

int map_manager::collision(vector_2 location)
{
    // Get the tile coordinates - no arbitrary offsets
    // We need to check multiple points for the character's bounding box
    int tile_x = location.x.integer() / 32;
    int tile_y = location.y.integer() / 32;

    // Clamp to map bounds
    if (tile_x < 0 || tile_x >= current_map->size.x.integer() ||
        tile_y < 0 || tile_y >= current_map->size.y.integer())
    {
        return 1; // Out of bounds is considered a collision
    }

    int tile_index = tile_x + (tile_y * current_map->size.x.integer());
    return current_map->collisions[tile_index];
}

int map_manager::action(vector_2 location)
{
    // Get the tile coordinates
    int tile_x = location.x.integer() / 32;
    int tile_y = location.y.integer() / 32;

    // Clamp to map bounds
    if (tile_x < 0 || tile_x >= current_map->size.x.integer() ||
        tile_y < 0 || tile_y >= current_map->size.y.integer())
    {
        return 0; // Out of bounds has no action
    }

    int tile_index = tile_x + (tile_y * current_map->size.x.integer());
    return current_map->actions[tile_index];
}

bool map_manager::check_box_collision(bound box)
{
    // Check all four corners of the bounding box
    int left = (box.position.x.integer() - box.width.integer() / 2);
    int right = (box.position.x.integer() + box.width.integer() / 2 - 1);
    int top = (box.position.y.integer() - box.height.integer() / 2);
    int bottom = (box.position.y.integer() + box.height.integer() / 2 - 1);

    // Check corners
    if (collision({left, top}) > 0)
        return true;
    if (collision({right, top}) > 0)
        return true;
    if (collision({left, bottom}) > 0)
        return true;
    if (collision({right, bottom}) > 0)
        return true;

    // For wider sprites, also check middle points
    if (box.width.integer() > 32)
    {
        int mid_x = box.position.x.integer();
        if (collision({mid_x, top}) > 0)
            return true;
        if (collision({mid_x, bottom}) > 0)
            return true;
    }

    if (box.height.integer() > 32)
    {
        int mid_y = box.position.y.integer();
        if (collision({left, mid_y}) > 0)
            return true;
        if (collision({right, mid_y}) > 0)
            return true;
    }

    return false;
}

ge_map_data.cpp: 
// Auto-Generated Map Template

#include "ge_maps.h"
#include "bn_regular_bg_items_map_forest_01.h"
#include "bn_regular_bg_items_map_garbage_01.h"
#include "bn_regular_bg_items_map_garbage_02.h"
#include "bn_regular_bg_items_map_garbage_03.h"
#include "bn_regular_bg_items_map_garbage_04.h"
#include "bn_regular_bg_items_map_garbage_05.h"
#include "bn_regular_bg_items_map_lab_01.h"
#include "bn_regular_bg_items_map_room01.h"
#include "bn_regular_bg_items_map_viskers_house.h"

constexpr map map_forest_01 = {
    {128, 12},
    {4096, 4096},
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,25,18,18,18,18,93,95,18,18,18,0,0,0,0,0,0,0,0,0,0,0,44,48,44,43,47,44,48,35,100,104,108,112,1,42,46,42,46,42,34,0,0,23,93,95,21,0,0,32,43,47,48,47,48,49,0,25,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42,46,19,19,19,58,94,96,58,19,19,42,46,1,0,0,0,0,0,0,0,0,43,47,43,44,34,45,49,0,101,105,109,113,32,43,47,43,47,43,35,0,0,0,94,96,0,0,0,33,44,48,47,48,49,0,0,25,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,0,0,0,0,0,0,32,43,47,34,0,0,0,0,0,0,0,32,43,47,34,32,43,44,48,44,48,44,48,44,48,44,43,47,34,0,0,102,106,110,114,33,44,48,49,45,49,0,0,0,0,0,0,0,0,0,32,48,47,48,49,32,34,0,25,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,0,0,0,0,0,0,33,44,48,35,0,0,0,0,0,0,0,33,44,48,35,33,35,43,47,43,47,43,47,43,47,43,44,48,35,0,0,103,107,111,115,0,45,49,0,0,0,0,0,0,0,0,0,0,0,32,43,47,48,49,32,43,47,34,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,0,42,46,42,46,42,46,45,49,0,0,0,0,0,0,0,0,0,45,49,0,0,42,44,48,44,48,44,48,44,48,44,45,49,0,0,68,0,0,0,0,32,34,0,0,42,46,42,46,42,46,42,46,0,32,43,47,48,49,32,43,44,48,35,0,0,0,0,0,0,0,0,0,0,0,
	79,72,74,80,23,18,18,21,80,76,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,0,0,0,0,0,0,0,0,0,0,0,0,32,43,47,43,47,43,47,34,0,0,0,0,0,0,0,0,0,0,0,0,0,32,43,47,43,47,43,47,43,47,43,47,34,0,0,0,0,0,0,0,0,33,35,0,32,43,47,43,47,43,47,43,47,34,33,44,48,49,0,33,44,48,49,1,0,0,0,0,0,0,0,0,0,0,0,
	80,73,75,81,23,93,95,21,81,77,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,0,0,0,0,0,0,0,0,0,0,0,0,33,44,48,44,48,44,48,35,0,0,0,0,0,0,0,0,0,0,0,0,0,33,44,48,44,48,44,48,44,48,44,48,35,0,0,0,0,0,0,0,0,0,0,0,33,44,48,44,48,44,48,44,48,35,0,45,49,0,0,0,45,49,0,25,18,0,0,0,0,0,0,0,0,0,0,
	79,0,0,0,0,94,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,81,81,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45,49,45,49,45,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45,49,45,49,45,49,45,49,45,49,0,0,0,0,0,0,0,0,0,0,0,0,0,45,49,45,49,45,49,45,49,0,0,0,0,0,0,0,0,0,0,25,0,145,146,146,26,27,27,27,28,0,0,
	80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,86,87,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42,46,42,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,
	79,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,43,47,43,47,34,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,19,148,147,147,22,0,0,0,20,0,0,
	80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,145,146,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,17,3,42,46,42,46,42,46,42,46,42,46,33,44,48,44,48,35,1,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,42,46,1,0,0,0,0,0,0,0,20,21,19,0,0,0,23,22,1,20,21,0,0,
	80,82,83,82,83,82,83,82,83,82,83,82,83,82,83,82,83,82,83,82,83,82,83,82,83,83,0,0,83,82,82,83,82,83,82,83,82,83,82,83,83,83,82,83,82,83,82,83,82,83,82,83,82,83,83,32,43,47,43,47,43,47,43,47,43,47,46,45,49,45,49,1,32,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,43,47,34,42,46,20,18,18,18,18,21,21,19,0,0,0,23,23,18,21,21,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,41,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,43,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,37,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,49,0,0,45,0,0,0,0,0,0,46,0,0,0,0,0,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,49,0,0,0,0,0,0,0,0,0,0,47,0,0,0,0,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_forest_01};



constexpr map map_garbage_01 = {
    {24, 12},
    {768, 768},
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,24,3,3,3,3,3,3,14,16,3,3,3,3,3,3,3,3,3,3,3,3,3,25,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,4,0,0,10,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,5,0,0,8,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,
	0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,
	0,23,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,22,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_garbage_01};



constexpr map map_garbage_02 = {
    {26, 12},
    {1024, 1024},
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,6,3,3,3,3,3,3,3,15,17,3,4,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,8,2,2,2,2,2,2,2,2,2,14,16,12,0,0,0,0,0,0,0,0,0,0,0,0,
	0,12,3,3,3,3,3,3,3,3,3,15,17,5,0,0,0,8,2,2,2,2,2,2,5,0,
	0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,
	0,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,
	0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,
	0,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_garbage_02};



constexpr map map_garbage_03 = {
    {12, 12},
    {512, 512},
    {
	0,0,0,0,0,0,0,0,0,0,0,0,
	6,2,2,2,2,2,2,2,14,16,4,0,
	0,0,0,0,0,0,0,0,0,0,13,0,
	0,0,0,0,0,0,0,0,0,0,13,0,
	7,3,3,3,3,3,27,4,0,0,13,0,
	0,0,0,0,0,66,27,29,0,0,13,0,
	0,0,0,0,0,67,28,30,0,0,13,0,
	0,6,2,2,2,14,16,5,0,0,13,0,
	0,0,0,0,0,0,0,0,0,0,13,0,
	0,0,0,0,0,0,0,0,0,0,13,0,
	0,7,3,3,3,3,3,3,3,3,5,0,
	0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,14,0,0,15,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-54,0,0,0,0,0,0,0,0,0,0,0,-51,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,16,15,0,0,0,0,0,0,17,0,0,0,16,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_garbage_03};



constexpr map map_garbage_04 = {
    {32, 24},
    {1024, 1024},
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,16,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,6,2,2,2,2,4,0,0,6,2,2,2,2,4,6,2,15,17,2,2,2,2,2,2,2,2,2,2,2,4,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,13,61,62,12,0,0,0,0,13,12,0,0,0,0,27,3,3,3,3,3,3,3,3,3,5,0,
	0,12,0,0,0,0,0,0,0,0,0,0,0,0,13,12,0,0,0,0,28,63,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,0,0,0,0,0,0,0,0,13,12,0,0,0,0,29,64,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,13,68,69,12,0,0,0,0,0,0,0,0,0,0,30,2,2,2,2,2,2,2,2,2,4,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,13,0,0,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,13,0,0,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,13,12,0,0,0,0,27,3,3,3,3,3,3,3,3,3,5,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,13,12,0,0,0,0,28,63,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,13,0,0,12,0,0,0,0,13,12,0,0,0,0,29,64,0,0,0,0,0,0,0,0,0,0,
	0,12,0,0,0,0,27,2,2,2,0,0,0,0,13,12,0,0,0,0,30,2,2,2,2,2,2,2,2,2,4,0,
	0,12,0,0,0,0,0,0,0,0,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,0,0,0,0,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,
	0,7,3,3,3,3,3,3,3,3,3,3,3,3,5,7,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_garbage_04};



constexpr map map_garbage_05 = {
    {10, 48},
    {1536, 1536},
    {
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,0,0,66,0,0,63,0,0,0,
	0,0,65,67,0,0,64,0,0,0,
	0,66,0,0,0,0,63,0,0,0,
	0,67,0,0,0,0,64,0,0,0,
	0,66,0,0,63,68,0,0,0,0,
	0,67,0,0,64,0,0,0,0,0,
	0,66,0,0,64,0,0,0,0,0,
	0,67,0,0,63,0,0,0,0,0,
	0,66,0,0,64,65,61,65,0,0,
	0,66,0,0,0,0,0,0,63,0,
	0,67,0,0,0,0,0,0,64,0,
	0,0,68,69,68,66,0,0,64,0,
	0,0,0,0,0,67,0,0,63,0,
	0,0,0,0,0,66,0,0,64,0,
	0,0,0,0,0,67,0,0,63,0,
	0,0,0,0,0,66,0,0,64,0,
	0,0,0,0,0,66,0,0,63,0,
	0,0,0,0,65,61,0,0,64,0,
	0,0,0,66,0,0,0,0,63,0,
	0,0,0,67,0,0,0,0,64,0,
	0,0,0,66,0,0,63,68,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,0,0,66,0,0,63,0,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,0,0,66,0,0,63,0,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,0,0,66,0,0,63,0,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,0,0,66,0,0,63,0,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,0,0,66,0,0,63,0,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,0,0,66,0,0,63,0,0,0,
	0,0,0,67,0,0,64,0,0,0,
	0,14,16,27,0,0,28,14,16,0,
	0,12,0,0,0,0,0,0,9,0,
	0,12,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,0,0,13,0,
	0,12,0,0,0,0,0,0,13,0,
	0,7,3,3,60,60,3,3,11,0,
	0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,26,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_garbage_05};



constexpr map map_lab_01 = {
    {31, 17},
    {1024, 1024},
    {
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	40,3,4,4,4,4,4,2,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	40,32,0,32,0,32,0,32,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	40,33,0,33,0,33,0,33,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	40,0,0,0,0,0,0,0,3,4,4,4,4,4,4,29,29,31,30,29,29,4,11,11,11,11,11,11,11,11,41,
	40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,41,
	2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,40,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,1,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,1,0,
	0,0,0,40,15,15,15,15,15,15,4,4,4,42,43,44,18,4,23,25,4,4,4,4,4,4,4,4,0,4,2,
	4,4,4,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,28,0,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,29,0,0,0,30,30,30,30,30,30,30,30,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,34,34,34,34,34,0,0,0,0,0,0,33,0,32,32,0,0,0,0,0,31,0,0,0,0,0,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,0,0,0,0,0,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_lab_01};



constexpr map map_room01 = {
    {12, 8},
    {512, 512},
    {
	10,1,3,15,16,38,40,22,20,21,6,9,
	8,2,4,13,14,39,0,23,17,18,19,7,
	42,0,0,0,0,0,0,0,0,0,0,7,
	43,0,0,0,32,34,36,0,0,0,0,7,
	8,0,0,0,0,0,0,0,0,0,0,7,
	8,44,0,0,0,0,0,0,0,0,30,7,
	8,31,0,0,0,0,0,0,0,0,31,7,
	11,5,5,5,5,5,5,5,5,5,5,12
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_room01};



constexpr map map_viskers_house = {
    {8, 8},
    {256, 256},
    {
	0,0,0,0,0,0,0,0,
	0,6,2,15,17,2,4,0,
	0,12,54,0,0,0,13,0,
	0,12,55,0,0,0,13,0,
	0,12,0,0,0,0,13,0,
	0,12,0,0,0,0,13,0,
	0,10,3,0,0,3,11,0,
	0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,11,0,0,0,0,0,0,10,0,0,13,0,0,0,0,10,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0,0,0
    },
    {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },
    &bn::regular_bg_items::map_viskers_house};




ge_sprites.cpp: 
#include "bn_log.h"
#include "bn_sprites.h"
#include "bn_sprite_item.h"
#include "bn_sprite_ptr.h"

// Body Sprites
#include "bn_sprite_items_spr_vista_01.h"
#include "bn_sprite_items_spr_jeremy_01.h"
#include "bn_sprite_items_spr_visker_01.h"
#include "bn_sprite_items_spr_visker_wife_01.h"
#include "bn_sprite_items_spr_ginger_01.h"

#include "ge_structs.h"
#include "ge_text.h"
#include "ge_sprites.h"
#include "ge_maps.h"
#include "ge_animations.h"

using namespace bn;

// Static member definitions
vector<v_sprite_ptr *, 12> v_sprite_ptr::manager;
vector_2 v_sprite_ptr::camera = {0, 0};

bool within_bounds(bound me, bound you)
{
    int me_x = me.position.x.integer();
    int me_y = me.position.y.integer();
    int you_x = you.position.x.integer();
    int you_y = you.position.y.integer();
    int width = you.width.integer() / 2;
    int height = you.height.integer() / 2;

    return (me_x > you_x - width && me_x < you_x + width) && (me_y > you_y - height && me_y < you_y + height);
}

v_sprite_ptr::v_sprite_ptr()
    : sprite_item_ptr(nullptr), frame(0)
{
    bounds.position = {0, 0};
    bounds.width = 0;
    bounds.height = 0;
    manager.push_back(this);
}

v_sprite_ptr::v_sprite_ptr(const sprite_item *sprite_item_ptr_, vector_2 position, int width, int height, int frame_)
    : sprite_item_ptr(sprite_item_ptr_), frame(frame_)
{
    bounds.position = position;
    bounds.width = width;
    bounds.height = height;
    manager.push_back(this);
}

v_sprite_ptr::~v_sprite_ptr()
{
    // Clear sprites before removing from manager
    sprite_ptr_raw[0].reset();
    sprite_ptr_raw[1].reset();

    // Remove this instance from the manager
    for (auto it = manager.begin(); it != manager.end(); ++it)
    {
        if (*it == this)
        {
            manager.erase(it);
            break;
        }
    }
}

void v_sprite_ptr::move(vector_2 direction)
{
    bounds.position.x = bounds.position.x + direction.x;
    bounds.position.y = bounds.position.y + direction.y;
}

bound v_sprite_ptr::real_position() const
{
    return {
        {bounds.position.x - camera.x, bounds.position.y - camera.y},
        bounds.width,
        bounds.height};
}

void v_sprite_ptr::set_frame(int frame_)
{
    frame = frame_;

    if (sprite_ptr_raw[0].has_value())
    {
        // Always use tall sprite logic
        // Top sprite uses frame * 2
        sprite_ptr_raw[0].value().set_tiles(sprite_item_ptr->tiles_item(), frame * 2);

        // Bottom sprite uses (frame * 2) + 1
        if (sprite_ptr_raw[1].has_value())
        {
            sprite_ptr_raw[1].value().set_tiles(sprite_item_ptr->tiles_item(), (frame * 2) + 1);
        }
    }
}

void v_sprite_ptr::update(bool dialogue_box_ended)
{
    for (auto *item : manager)
    {
        bound bounds = item->real_position();
        bound acceptable = {screen.position, screen.width + 32, screen.height + 32};

        if (!dialogue_box_ended)
        {
            acceptable.position.y = 0 - (screen_height / 2) + 12;
        }

        if (item->sprite_ptr_raw[0].has_value())
        {
            // Sprite exists - check if it should be removed or updated
            if (!within_bounds(bounds, acceptable))
            {
                // Out of bounds - remove sprites
                item->sprite_ptr_raw[0].reset();
                item->sprite_ptr_raw[1].reset();
            }
            else
            {
                // Update z-order for both sprites
                item->sprite_ptr_raw[0].value().set_z_order(10 - item->sprite_ptr_raw[0].value().y().integer() / 16);
                item->sprite_ptr_raw[1].value().set_z_order(10 - item->sprite_ptr_raw[0].value().y().integer() / 16);

                // Always update both sprites (tall sprites)
                item->sprite_ptr_raw[0].value().set_position(bounds.position.x, bounds.position.y - 32);
                item->sprite_ptr_raw[0].value().set_tiles(item->sprite_item_ptr->tiles_item(), item->frame * 2);

                if (item->sprite_ptr_raw[1].has_value())
                {
                    item->sprite_ptr_raw[1].value().set_position(bounds.position.x, bounds.position.y);
                    item->sprite_ptr_raw[1].value().set_tiles(item->sprite_item_ptr->tiles_item(), (item->frame * 2) + 1);
                }
            }
        }
        else if (within_bounds(bounds, acceptable))
        {
            // Sprite doesn't exist but is in bounds - create it
            if (item->sprite_item_ptr != nullptr) // Safety check
            {
                // Always create both sprites for tall characters
                item->sprite_ptr_raw[0] = item->sprite_item_ptr->create_sprite(bounds.position.x, bounds.position.y - 32, item->frame * 2);
                item->sprite_ptr_raw[1] = item->sprite_item_ptr->create_sprite(bounds.position.x, bounds.position.y, (item->frame * 2) + 1);
            }
        }
    }
}

character::character(int index_, vector_2 start_) : index(index_)
{
    v_sprite.bounds.position = {
        (start_.x * 32) + 16,
        (start_.y * 32) + 16};
    v_sprite.bounds.width = 28;
    v_sprite.bounds.height = 28;

    switch (index_)
    {
    case CHAR_VISTA:
    {
        v_sprite.sprite_item_ptr = &bn::sprite_items::spr_vista_01;
        break;
    }
    case CHAR_JEREMY:
    {
        v_sprite.sprite_item_ptr = &bn::sprite_items::spr_jeremy_01;
        break;
    }
    case CHAR_VISKER:
    {
        v_sprite.sprite_item_ptr = &bn::sprite_items::spr_visker_01;
        break;
    }
    case CHAR_VISKER_WIFE:
    {
        v_sprite.sprite_item_ptr = &bn::sprite_items::spr_visker_wife_01;
        break;
    }
    case CHAR_GINGER:
    {
        v_sprite.sprite_item_ptr = &bn::sprite_items::spr_ginger_01;
        break;
    }

    default:
    {
        break;
    }
    }

    // Reset sprites
    v_sprite.sprite_ptr_raw[0].reset();
    v_sprite.sprite_ptr_raw[1].reset();
    current_animation = &anim_stand;

    if (type() == CH_TYPE_PLAYER || (v_sprite_ptr::camera.x == 0 && v_sprite_ptr::camera.y == 0))
    {
        v_sprite_ptr::camera.x = start_.x;
        v_sprite_ptr::camera.y = start_.y;
    }
}

void character::update(map_manager *current_map, bool db_inactive)
{
    vector_2 delta = {0, 0};

    if (type() == CH_TYPE_PLAYER)
    {
        if (db_inactive)
        {
            move_to.x = 0;
            move_to.y = 0;
            idle_animation = nullptr;
        }

        vector_2 bound_1 = {
            (screen_width / 2),
            (screen_height / 2)};

        vector_2 bound_2 = {
            (current_map->current_map->size.x * 32) - bound_1.x,
            (current_map->current_map->size.y * 32) - bound_1.y};

        if (db_inactive)
        {
            if (bn::keypad::up_held())
            {
                delta.y = -1;
            }

            if (bn::keypad::down_held())
            {
                delta.y = 1;
            }

            if (bn::keypad::left_held())
            {
                delta.x = -1;
            }

            if (bn::keypad::right_held())
            {
                delta.x = 1;
            }
        }

        v_sprite_ptr::camera.x = v_sprite.bounds.position.x;

        if (!db_inactive && index != CHAR_VISTA)
        {
            if (v_sprite.bounds.position.y > v_sprite_ptr::camera.y)
            {
                v_sprite_ptr::camera.y = v_sprite.bounds.position.y;
            }
        }
        else
        {
            v_sprite_ptr::camera.y = v_sprite.bounds.position.y;
        }

        if (v_sprite_ptr::camera.x < bound_1.x)
            v_sprite_ptr::camera.x = bound_1.x;

        if (v_sprite_ptr::camera.x > bound_2.x)
            v_sprite_ptr::camera.x = bound_2.x;
    }
    else
    {
        if (!db_inactive)
        {
            if (v_sprite.sprite_ptr_raw[0].has_value())
            {
                // Calculate where this sprite appears on screen
                bound screen_pos = v_sprite.real_position();

                // Keep sprites at y=0 or above for ~80 pixels of buffer from dialogue box
                if (screen_pos.position.y > 0)
                {
                    // Move camera down just enough to keep sprite above this threshold
                    fixed adjustment = screen_pos.position.y - 0;
                    v_sprite_ptr::camera.y += adjustment;
                }
            }
        }
    }

    // Fixed move_to logic with proper directions
    if (move_to.x != 0 && move_to.y != 0)
    {
        vector_2 move_to_exp = {
            (move_to.x * 32) + 16,
            (move_to.y * 32) + 16};

        if (move_to_exp.x > v_sprite.bounds.position.x)
        {
            delta.x = 1;
        }
        else if (move_to_exp.x < v_sprite.bounds.position.x)
        {
            delta.x = -1;
        }

        if (move_to_exp.y > v_sprite.bounds.position.y)
        {
            delta.y = 1;
        }
        else if (move_to_exp.y < v_sprite.bounds.position.y)
        {
            delta.y = -1;
        }
    }

    // Fixed facing direction
    if (delta.y > 0)
    {
        face = DIR_DOWN;
    }
    else if (delta.y < 0)
    {
        face = DIR_UP;
    }

    if (delta.x > 0)
    {
        face = DIR_RIGHT;
    }
    else if (delta.x < 0)
    {
        face = DIR_LEFT;
    }

    if (keypad::b_held())
    {
        delta.x = delta.x * 2;
        delta.y = delta.y * 2;
    }

    // Pixel-perfect collision detection
    // Check future position for each axis separately
    bound future_bounds_x = v_sprite.bounds;
    future_bounds_x.position.x = future_bounds_x.position.x + delta.x;

    bound future_bounds_y = v_sprite.bounds;
    future_bounds_y.position.y = future_bounds_y.position.y + delta.y;

    // Check X movement
    if (current_map->check_box_collision(future_bounds_x))
    {
        delta.x = 0;
    }

    // Check Y movement
    if (current_map->check_box_collision(future_bounds_y))
    {
        delta.y = 0;
    }

    // For diagonal movement, also check the combined movement
    if (delta.x != 0 && delta.y != 0)
    {
        bound future_bounds_both = v_sprite.bounds;
        future_bounds_both.position.x = future_bounds_both.position.x + delta.x;
        future_bounds_both.position.y = future_bounds_both.position.y + delta.y;

        if (current_map->check_box_collision(future_bounds_both))
        {
            // Try to slide along walls
            // If diagonal fails but individual axes might work, keep the working axis
            if (delta.x != 0 && !current_map->check_box_collision(future_bounds_x))
            {
                delta.y = 0; // Can move X but not Y
            }
            else if (delta.y != 0 && !current_map->check_box_collision(future_bounds_y))
            {
                delta.x = 0; // Can move Y but not X
            }
            else
            {
                // Can't move in either direction
                delta.x = 0;
                delta.y = 0;
            }
        }
    }

    // Apply movement with fixed direction
    v_sprite.bounds.position.x = v_sprite.bounds.position.x + delta.x;
    v_sprite.bounds.position.y = v_sprite.bounds.position.y + delta.y;

    bool moving = (delta.x != 0 || delta.y != 0);

    // Animation and sprite update code
    bool custom_anim = false;
    if (moving)
    {
        current_animation = &anim_walk;
    }
    else if (idle_animation == nullptr)
    {
        current_animation = &anim_stand;
    }
    else
    {
        if (current_animation != idle_animation)
        {
            frame = 0;
        }
        current_animation = idle_animation;
        custom_anim = true;
    }

    // Rest of the update code...
    if (v_sprite.sprite_ptr_raw[0].has_value())
    {
        int ticker_speed;

        switch (current_animation->speed)
        {
        case SP_SLOW:
        {
            ticker_speed = 12;
            break;
        }
        case SP_FAST:
        {
            ticker_speed = 3;
            break;
        }
        default:
        {
            ticker_speed = 6;
            break;
        }
        }

        if (current_animation->loop)
        {
            if (ticker % ticker_speed == 0)
            {
                frame = (frame + 1) % current_animation->size;
            }
        }
        else
        {
            if (ticker % ticker_speed == 0 && frame < current_animation->size - 1)
            {
                frame++;
            }
        }

        int new_frame = current_animation->frames[frame];

        // Always set horizontal flip for both sprites
        v_sprite.sprite_ptr_raw[0].value().set_horizontal_flip(false);
        v_sprite.sprite_ptr_raw[1].value().set_horizontal_flip(false);

        if (!custom_anim)
        {
            switch (face)
            {
            case DIR_UP:
                v_sprite.set_frame(new_frame + 6);
                break;
            case DIR_DOWN:
                v_sprite.set_frame(new_frame);
                break;
            case DIR_LEFT:
                v_sprite.set_frame(new_frame + 3);
                v_sprite.sprite_ptr_raw[0].value().set_horizontal_flip(true);
                v_sprite.sprite_ptr_raw[1].value().set_horizontal_flip(true);
                break;
            case DIR_RIGHT:
                v_sprite.set_frame(new_frame + 3);
                break;
            default:
            {
                break;
            }
            }
        }
        else
        {
            v_sprite.set_frame(new_frame);
        }
    }

    ticker++;
}

void character::add(list<character, 32> *characters, int character_id, vector_2 location)
{
    characters->emplace_back(character_id, location);
}

ge_structs.cpp: 
// ge_structs.cpp
#include "bn_fixed.h"

using namespace bn;

constexpr int screen_width = 240;
constexpr int screen_height = 160;

struct vector_2
{
    fixed_t<4> x;
    fixed_t<4> y;
};

struct bound
{
    vector_2 position;
    fixed_t<4> width;
    fixed_t<4> height;
};

constexpr bound screen = {{0, 0}, screen_width, screen_height};

ge_text.cpp: 
// Implementation file (ge_text.cpp)

#include "bn_log.h"
#include "bn_sound_items.h"
#include "bn_sound_items_info.h"
#include "bn_random.h"

#include "ge_sprites.h"
#include "ge_globals.h"
#include "ge_text.h"
#include "ge_character_manager.h"

#include "bn_music.h"
#include "bn_music_items.h"
#include "bn_music_items_info.h"

// Sprites
#include "bn_sprite_items_spr_font_01.h"
#include "bn_regular_bg_items_bg_dialogue_box.h"

#include "bn_sprite_items_db_ch_jeremy.h"
#include "bn_sprite_items_db_ch_vista.h"
#include "bn_sprite_items_db_ch_visker.h"
#include "bn_sprite_items_db_ch_visker_wife.h"
#include "bn_sprite_items_db_ch_ginger.h"

using namespace bn;

constexpr char alphabet[] = {
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '`', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
    '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+',
    '[', ']', '\\', '{', '}', '|', ';', '\'', ':', '"', ',', '.', '/',
    '<', '>', '?'};

vector<toast, 16> text::toasts;

letter::letter(char ch, vector_2 ideal_position_) : ideal_position(ideal_position_)
{
    char_index = -1;

    for (size_t i = 0; i < sizeof(alphabet); ++i)
    {
        if (ch == alphabet[i])
        {
            char_index = i;
            break;
        }
    }

    if (char_index > -1)
    {
        sprite = sprite_items::spr_font_01.create_sprite(ideal_position_.x, ideal_position_.y, char_index);
    }
}

void letter::update(bool shake, int size)
{
    if (size == SIZE_LARGE)
    {
        sprite.value().set_scale(2, 2);
    }
    else if (size == SIZE_SMALL)
    {
        sprite.value().set_scale(0.75, 0.75);
    }

    if (shake)
    {
        temp_position = {
            ideal_position.x + global_data_ptr->bn_random.get_int(6) - 3,
            ideal_position.y + global_data_ptr->bn_random.get_int(6) - 3,
        };

        if (sprite.value().x().integer() < temp_position.x.integer())
        {
            sprite.value().set_x(sprite.value().x() + 1);
        }
        else if (sprite.value().x() > temp_position.x.integer())
        {
            sprite.value().set_x(sprite.value().x() - 1);
        }

        if (sprite.value().y().integer() < temp_position.y.integer())
        {
            sprite.value().set_y(sprite.value().y() + 1);
        }
        else if (sprite.value().y().integer() > temp_position.y.integer())
        {
            sprite.value().set_y(sprite.value().y() - 1);
        }
    }
}

text::text()
{
}

text::text(vector_2 start_) : start(start_)
{
}

text::text(const char *value, vector_2 start_) : start(start_)
{
    if (value)
        init(value);
}

text::text(const string<20> &value, vector_2 start_) : start(start_)
{
    reference = value;
    letters.clear();
    current_x = 0;
    index = 0;
}

void text::init(const char *value)
{
    if (!value)
    {
        reference.clear();
        letters.clear();
        current_x = 0;
        index = 0;
        return;
    }

    // Convert C-string to bn::string
    reference = string<20>(value);
    letters.clear();
    current_x = 0;
    index = 0;
}

void text::update(const bn::sprite_item *portrait = nullptr, bool typewriter = false)
{
    if (index >= reference.size() || is_ended())
    {
        return;
    }

    if (index % 2 == 0)
    {
        if (portrait == &sprite_items::db_ch_vista || portrait == &sprite_items::db_ch_ginger)
        {
            sound_items::snd_dialogue_vista.play(0.7);
        }
        else if (portrait == &sprite_items::db_ch_jeremy)
        {
            sound_items::snd_dialogue_jeremy.play(0.7);
        }
        else if (portrait == &sprite_items::db_ch_visker)
        {
            sound_items::snd_dialogue_visker.play(0.4);
        }
        else if (typewriter)
        {
            sound_items::snd_dialogue_typewriter.play(0.5);
        }
        else
        {
            sound_items::snd_dialogue_generic.play(0.5);
        }
    }

    char ch = reference[index];

    int current_size = SIZE_DEFAULT;
    int spacing = 8; // Default portrait spacing

    // Adjust spacing based on size
    if (current_size == SIZE_LARGE)
    {
        spacing = 16; // Larger spacing for large text
    }
    else if (current_size == SIZE_SMALL)
    {
        spacing = 6; // Smaller spacing for small text
    }

    if (ch == ' ')
    {
        current_x += spacing; // Use the size-adjusted spacing
        index++;
        return;
    }

    // Create letter at current position
    letter new_letter = {ch, {start.x + current_x, start.y}};

    if (new_letter.char_index > -1)
    {
        letters.push_back(new_letter);
        current_x += spacing; // Use size-adjusted spacing instead of hardcoded 8
        index++;
    }
}

void text::render()
{
    // Clear any existing letters first
    letters.clear();
    current_x = 0;

    // Check if reference is empty before processing
    if (reference.empty())
    {
        index = 0;
        return;
    }

    index = 0;
    while (index < reference.size())
    {
        int current_size = SIZE_DEFAULT;
        int spacing = 8; // Default spacing

        // Adjust spacing based on size
        if (current_size == SIZE_LARGE)
        {
            spacing = 16; // Larger spacing for large text
        }
        else if (current_size == SIZE_SMALL)
        {
            spacing = 6;
        }

        char ch = reference[index];

        if (ch == ' ')
        {
            current_x += spacing;
            index++;
        }
        else
        {
            // Create letter at current position
            letter new_letter = {ch, {start.x + current_x, start.y}};

            if (new_letter.char_index > -1)
            {
                letters.push_back(new_letter);
                current_x += spacing;
            }
            index++;
        }
    }
}

bool text::is_ended()
{
    return index >= reference.size() || reference[index] == '\0'; // Fixed end condition
}

void text::set_position(int x, int y)
{
    start.x = x;
    start.y = y;
    int current_x_pos = x;
    for (auto &letter : letters)
    {
        letter.ideal_position = {current_x_pos, y};
        current_x_pos += 8;
    }
}

dialogue_box::dialogue_box()
{
    box = regular_bg_items::bg_dialogue_box.create_bg(0, 0);
    pointer = sprite_items::spr_font_01.create_sprite(-52, 32, 73);
    ticker = 0;
    active_conversation = nullptr;
    index = 0;
    size = 0;
}

void dialogue_box::load(conversation *new_conversation)
{
    active_conversation = new_conversation;
    index = 0;
    size = 0;

    for (int i = 0; i < 64; i++)
    {
        if ((*active_conversation)[i].action == ACT_END)
        {
            break;
        }
        size++;
    }
}

void dialogue_box::init(character_manager *ch_man)
{
    if (!active_conversation || is_ended())
    {
        return;
    }

    bool skip = false;

    do
    {
        skip = false;
        const dialogue_line &line = (*active_conversation)[index];

        if (line.portrait != nullptr)
        {
            portrait = line.portrait->create_sprite(-84, 56, line.emotion);
        }
        else
        {
            portrait.reset();
        }

        if (line.action == ACT_SPAWN)
        {
            ch_man->add_character(line.index, line.navigate);
        }

        auto ch = ch_man->find_by_index(line.index);
        if (ch)
        {
            if (line.navigate.x != 0 && line.navigate.y != 0)
            {
                if (line.action == ACT_TELEPORT)
                {
                    ch->v_sprite.bounds.position.x = line.navigate.x * 32;
                    ch->v_sprite.bounds.position.y = line.navigate.y * 32;
                }
                else if (line.action == ACT_WALK)
                {
                    ch->move_to = line.navigate;
                }
            }
            ch->idle_animation = line.anim;

            if (ch->idle_animation != nullptr)
            {
                BN_LOG(ch->idle_animation->size);
            }
        }

        for (int t = 0; t < 3; t++)
        {
            BN_LOG(line.raw_text[t]);
            lines[t].init(line.raw_text[t]);
            lines[t].size = line.size;
        }

        switch (line.action)
        {
        case ACT_SFX_KNOCK:
        {
            sound_items::sfx_knock.play();
            break;
        }
        case ACT_MUSIC_VISKER:
        {
            music::stop();
            music_items::theme_visker.play(0.75);
            break;
        }
        case ACT_MUSIC_GINGER:
        {
            music::stop();
            music_items::theme_ginger.play(0.75);
            break;
        }
        case ACT_MUSIC_FADEOUT:
        {
            break;
        }
        case ACT_MUSIC_RESET:
        {
            music::stop();
            global_data_ptr->bg_track->play(0.5);
            break;
        }
        case ACT_FIGHT:
        {
            auto pos = ch_man->player_ptr->v_sprite.bounds.position;
            global_data_ptr->entry_position = {pos.x.integer() / 32, pos.y.integer() / 32};
            global_data_ptr->battle_foe = line.index;
            ch_man->alert();
            break;
        }
        case ACT_PROGRESS:
        {
            global_data_ptr->process_stage = line.index;
            ch_man->status = NEW_CHAPTER;
            break;
        }
        case ACT_CUE_GINGER:
        {
            auto ginger = ch_man->find_by_index(CHAR_GINGER);
            ginger->is_follow = true;
            ginger->follow_id = CHAR_JEREMY;
            break;
        }
        default:
        {
            break;
        }
        }

        if (line.emotion == EM_SKIP)
        {
            skip = true;
            index++;
        }
    } while (skip);
}

void dialogue_box::update()
{
    if (!active_conversation || index >= size)
    {
        return;
    }

    auto l = (*active_conversation)[index];

    // Only update portrait if it exists and has a valid portrait pointer
    if (portrait.has_value() && l.portrait != nullptr)
    {
        portrait.value().set_tiles(l.portrait->tiles_item(), (l.emotion * 2));
    }

    for (int t = 0; t < 3; t++)
    {
        for (auto &letter_ : lines[t].letters)
        {
            letter_.update(l.shake, l.size);
        }
    }

    if (!active_conversation || (lines[0].is_ended() && lines[1].is_ended() && lines[2].is_ended()))
    {
        return;
    }

    ticker++;

    // Speed controls go around here:

    if (portrait.has_value() && l.portrait != nullptr && ticker % 12 < 6)
    {
        portrait.value().set_tiles(l.portrait->tiles_item(), (l.emotion * 2) + 1);
    }

    if (ticker % 3 == 0)
    {
        for (int t = 0; t < 3; t++)
        {
            if (!lines[t].is_ended())
            {
                lines[t].update(l.portrait);
                return;
            }
        }
    }
}

bool dialogue_box::is_ended()
{
    if (!active_conversation)
    {
        return true;
    }
    return (*active_conversation)[index].action == ACT_END;
}

// Add this method to the dialogue_box class to check if current text is fully displayed
bool dialogue_box::is_text_complete()
{
    if (!active_conversation || index >= size)
    {
        return true;
    }

    // Check if all three lines are either ended or empty
    for (int i = 0; i < 3; i++)
    {
        if (!lines[i].reference.empty() && !lines[i].is_ended())
        {
            return false;
        }
    }
    return true;
}

// Add this method to instantly complete the current text
void dialogue_box::instant_complete_text()
{
    if (!active_conversation || index >= size)
    {
        return;
    }

    // Instantly render all three lines
    for (int i = 0; i < 3; i++)
    {
        if (!lines[i].reference.empty())
        {
            lines[i].render();
        }
    }
}

// Modified method to handle A button press
// This should be called from your main game loop or input handler
void dialogue_box::handle_a_button_press(character_manager *ch_man)
{
    if (!active_conversation || is_ended())
    {
        return;
    }

    if (is_text_complete())
    {
        // Text is fully displayed, advance to next dialogue
        advance(ch_man);
    }
    else
    {
        // Text is still being revealed, instantly complete it
        instant_complete_text();
    }
}

// Add this method to advance to the next dialogue line
void dialogue_box::advance(character_manager *ch_man)
{
    index++;

    if (!is_ended())
    {
        init(ch_man); // Initialize the next dialogue line
    }
}

char digit_conv(int digit)
{
    return (char)((digit % 10) + 48);
}

toast::toast() {}

void text::add_toast(string<20> value, vector_2 pos)
{
    toast new_toast;

    if (text::at_location(pos))
    {
        pos.y -= 16;
    }

    new_toast.value = text(value, pos);
    new_toast.ticker = 0;
    text::toasts.push_back(new_toast);

    // Render the new toast
    text::toasts.back().value.render();
}

void text::add_toast(int value, vector_2 pos)
{
    string<20> temp;

    // Handle zero case
    if (value == 0)
    {
        temp.push_back('0');
    }
    else
    {
        // Check if negative and store the sign
        bool is_negative = false;
        if (value < 0)
        {
            is_negative = true;
            value = -value; // Make it positive for digit extraction
        }

        // Extract digits and store them in reverse
        string<20> reversed;
        while (value > 0)
        {
            reversed.push_back(digit_conv(value));
            value = value / 10;
        }

        // Add negative sign first if needed
        if (is_negative)
        {
            temp.push_back('-');
        }

        // Now push the digits to temp in correct order
        for (int i = reversed.size() - 1; i >= 0; i--)
        {
            temp.push_back(reversed[i]);
        }
    }

    toast new_toast;

    if (text::at_location(pos))
    {
        pos.y -= 16;
    }

    new_toast.value = text(temp, pos);
    new_toast.ticker = 0;
    text::toasts.push_back(new_toast);

    // Render the new toast
    text::toasts.back().value.render();
}

bool text::at_location(vector_2 pos)
{
    for (auto &t : text::toasts)
    {
        if (t.value.start.x == pos.x && t.value.start.y == pos.y)
        {
            return true;
        }
    }
    return false;
}

void text::update_toasts()
{
    int delete_toast = -1;
    for (int t = 0; t < text::toasts.size(); t++)
    {
        text::toasts.at(t).ticker++;

        if (text::toasts.at(t).ticker > 96)
        {
            delete_toast = t;
        }
    }
    if (delete_toast > -1)
    {
        text::toasts.erase(text::toasts.begin() + delete_toast);
    }
}

main.cpp: 
// main.cpp
#include "bn_core.h"
#include "bn_log.h"
#include "bn_regular_bg_item.h"
#include "bn_string.h"
#include "bn_keypad.h"
#include "bn_list.h"
#include "bn_music.h"
#include "bn_music_items.h"
#include "bn_music_items_info.h"
#include "bn_sound_items.h"
#include "bn_math.h"

// Face Sprites
#include "bn_sprite_items_db_ch_jeremy.h"
#include "bn_sprite_items_db_ch_vista.h"

#include "bn_sprite_items_spr_vista_01.h"

#include "bn_regular_bg_items_floor_wood01.h"
#include "bn_regular_bg_items_big_bg_forest_01.h"

#include "main.h"
#include "ge_globals.h"
#include "ge_sprites.h"
#include "ge_text.h"
#include "ge_maps.h"
#include "ge_character_manager.h"
#include "ge_actions.h"
#include "ge_battle.h"

#include "ge_map_data.cpp"

using namespace bn;

int navigate_map()
{
    map_manager current_map(global_data_ptr->entry_map);
    character_manager char_mgr;

    for (int y = 0; y < current_map.current_map->size.y.integer(); y++)
    {
        for (int x = 0; x < current_map.current_map->size.x.integer(); x++)
        {
            int tile = x + (y * current_map.current_map->size.x.integer());

            if (current_map.current_map->characters[tile] != 0)
            {
                char_mgr.add_character(current_map.current_map->characters[tile] - 1, {x, y});
            }
        }
    }

    if (global_data_ptr->entry_map != &map_room01)
    {
        char_mgr.add_character(CHAR_JEREMY, global_data_ptr->entry_position);
    }

    int loop_value = 0;
    bool handle_frame = true;
    while (loop_value == CONTINUE && char_mgr.status == CONTINUE)
    {
        char_mgr.update(&current_map);
        loop_value = action_listener(&current_map, &char_mgr);
        current_map.update();
        bool dialogue_is_active = char_mgr.db.has_value() && !char_mgr.db.value().is_ended();
        v_sprite_ptr::update(!dialogue_is_active);

        if (current_map.bg_ptr.has_value())
        {
            current_map.bg_ptr.value().set_x(v_sprite_ptr::camera.x / -5);
            current_map.bg_ptr.value().set_y(v_sprite_ptr::camera.y / -5);
        }

        if (handle_frame)
        {
            handle_frame = false;
        }
        else
        {
            core::update();
        }
    }

    v_sprite_ptr::clear_all();
    return loop_value + char_mgr.status;
}

enum TYPEWRITER_SCENES
{
    TYPEWRITER_INTRO,
    TYPEWRITER_CREDITS,
    TYPEWRITER_INTRO2,
    TYPEWRITER_INTRO3,
    TYPEWRITER_TITLE,
    TYPEWRITER_GARBAGE,
    TYPEWRITER_MSG,
    TYPEWRITER_BUFFER
};

enum TYPEWRITER_TYPE
{
    TYPE_TEXT,
    TYPE_IMG
};

#include "bn_regular_bg_items_scene_cabin01.h"
#include "bn_regular_bg_items_scene_title01.h"

void typewriter(int scene)
{
    optional<regular_bg_ptr> frame;
    text lines[3] = {{nullptr, {-71 + 16, 36}}, {nullptr, {-71 + 16, 36 + 16}}, {nullptr, {-71 + 16, 36 + 32}}};
    conversation *current_conversation;
    int index = 0;
    int ticker = 0;
    int type = TYPE_IMG;

    switch (scene)
    {
    case TYPEWRITER_INTRO:
    {
        frame = regular_bg_items::scene_cabin01.create_bg(0, 0);
        current_conversation = &intro_01;
        music_items::intro.play(1);
        type = TYPE_TEXT;
        break;
    }
    case TYPEWRITER_TITLE:
    {
        frame = regular_bg_items::scene_title01.create_bg(0, 0);
        sound_items::snd_intro.play();
        music::stop();
        break;
    }
    case TYPEWRITER_INTRO2:
    {
        music::stop();
        current_conversation = &intro_02;
        type = TYPE_TEXT;
        break;
    }
    case TYPEWRITER_INTRO3:
    {
        current_conversation = &intro_03;
        type = TYPE_TEXT;
        break;
    }
    case TYPEWRITER_GARBAGE:
    {
        music::stop();
        sound_items::sfx_drag.play();
        break;
    }
    case TYPEWRITER_MSG:
    {
        music_items::shop.play();
        current_conversation = &final_msg;
        type = TYPE_TEXT;
        break;
    }
    case TYPEWRITER_BUFFER:
    {
        break;
    }
    default:
    {
        type = TYPE_IMG;
        music::stop();
        break;
    }
    }

    if (type == TYPE_TEXT)
    {
        // Initialize with first dialogue
        lines[0] = {(*current_conversation)[index].raw_text[0], {-71 + 16, 36}};
        lines[1] = {(*current_conversation)[index].raw_text[1], {-71 + 16, 36 + 16}};
        lines[2] = {(*current_conversation)[index].raw_text[2], {-71 + 16, 36 + 32}};

        while ((*current_conversation)[index].action != ACT_END)
        {
            if (keypad::a_pressed())
            {
                index++;

                // Check if we've reached the end
                if ((*current_conversation)[index].action == ACT_END)
                    break;

                BN_LOG((*current_conversation)[index].raw_text[0]);

                // Clear existing letters
                lines[0].letters.clear();
                lines[1].letters.clear();
                lines[2].letters.clear();

                // Reset indices for new text
                lines[0].index = 0;
                lines[1].index = 0;
                lines[2].index = 0;

                // Reinitialize with new text
                lines[0].init((*current_conversation)[index].raw_text[0]);
                lines[1].init((*current_conversation)[index].raw_text[1]);
                lines[2].init((*current_conversation)[index].raw_text[2]);
            }

            if (ticker % 5 == 0)
            {
                if (lines[0].is_ended())
                {
                    if (lines[1].is_ended())
                    {
                        lines[2].update(nullptr, true);
                    }
                    else
                    {
                        lines[1].update(nullptr, true);
                    }
                }
                else
                {
                    lines[0].update(nullptr, true);
                }
            }

            ticker++;
            core::update();
        }
    }
    else if (type == TYPE_IMG)
    {
        int wait = 96;
        if (frame.has_value())
        {
            wait = 192;
        }

        for (int t = 0; t < wait; t++)
        {
            core::update();
        }
    }
}

int main()
{
    core::init();

    int value = NEW_CHAPTER;

    // Set for debug
    global_data_ptr = new global_data();
    global_data_ptr->process_stage = FOREST_01; // CUTSCENE_01;

    // Test battle before game begins
    /*
    global_data_ptr->battle_foe = FOE_VISKERS_01;
    value = battle_map();
    core::update();
    value = NEW_CHAPTER;
    */

    while (true)
    {
        switch (value)
        {
        case BATTLE:
        {
            value = battle_map();
            break;
        }
        case NEW_CHAPTER:
        {
            switch (global_data_ptr->process_stage)
            {
            case CUTSCENE_01:
            {
                typewriter(TYPEWRITER_INTRO);
                global_data_ptr->entry_map = &map_room01;
                global_data_ptr->entry_position = {9, 2};
                break;
            }
            case CUTSCENE_TO_GARBAGE:
            {
                typewriter(TYPEWRITER_INTRO2);
                typewriter(TYPEWRITER_BUFFER);
                typewriter(TYPEWRITER_INTRO3);
                typewriter(TYPEWRITER_BUFFER);
                typewriter(TYPEWRITER_TITLE);
                typewriter(TYPEWRITER_BUFFER);

                global_data_ptr->entry_map = &map_garbage_01;
                global_data_ptr->entry_position = {9, 5};
                global_data_ptr->bg_track = &music_items::bg_garbage;
                break;
            }
            case GARBAGE_TO_BLACK:
            {
                typewriter(TYPEWRITER_GARBAGE);
                global_data_ptr->entry_map = &map_lab_01;
                global_data_ptr->entry_position = {4, 5};
                global_data_ptr->bg_track = &music_items::bg_office;
                break;
            }
            case BLACK_TO_LAB:
            {
                global_data_ptr->entry_map = &map_lab_01;
                global_data_ptr->entry_position = {4, 5};
                global_data_ptr->bg_track = &music_items::bg_office;
                break;
            }
            case FOREST_01:
            {
                global_data_ptr->bg = &regular_bg_items::big_bg_forest_01;
                global_data_ptr->entry_map = &map_forest_01;
                global_data_ptr->entry_position = {6, 8};
                global_data_ptr->bg_track = &music_items::forest_01;
                break;
            }
            case FINAL_MSG:
            {
                typewriter(TYPEWRITER_BUFFER);
                typewriter(TYPEWRITER_MSG);
                while (true)
                {
                    core::update();
                }
                break;
            }
            default:
            {
                global_data_ptr->entry_map = &map_garbage_01;
                global_data_ptr->entry_position = {9, 5};
                global_data_ptr->bg_track = &music_items::bg_garbage;
                break;
            }
            }

            value = CONTINUE;
            break;
        }
        default:
        {
            if (!music::playing())
            {
                global_data_ptr->bg_track->play();
            }

            value = navigate_map();
            break;
        }
        }

        core::update();
    }
}

ge_actions.h: 
// ge_actions.h

#include "ge_text.h"
#include "ge_sprites.h"
#include "ge_maps.h"
#include "ge_character_manager.h"
#include "ge_animations.h"

using namespace bn;

#include "bn_sprite_items_db_ch_vista.h"
#include "bn_sprite_items_db_ch_visker.h"
#include "bn_sprite_items_db_ch_jeremy.h"
#include "bn_sprite_items_db_ch_visker_wife.h"
#include "bn_sprite_items_db_ch_ginger.h"

constexpr conversation intro_01 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Deep within the", "woods of the", "old world,", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "There once", "lay a cabin.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Forgotten by", "the man who", "built it,", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Nearly forgotten", "by the woman", "who lived within,", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "The last of her", "kind, a Marelon,", "named Vista.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation test_convo = {
    {0, nullptr, EM_SKIP, ACT_WALK, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISTA, &vista_reminisce, {2, 6}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "In her cabin,", "most days were", "just the same.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "She read her books", "and cared for her", "sawdust doll.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_SFX_KNOCK, "But today,", "there was a knock", "at the door.", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISTA, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_vista, EM_DEFAULT, ACT_WALK, "Yes?", "Who is it?", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISTA, &vista_pickup, {1, 3}},
    {0, &sprite_items::db_ch_vista, EM_SULLEN, ACT_DEFAULT, "Hmm,", "What could this be?", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_vista, EM_HAPPY, ACT_DEFAULT, "\"Dear Vista,", "I don't know if you", "remember me..\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_vista, EM_DEFAULT, ACT_DEFAULT, "\"I was your", "daughter, years", "and years ago.\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_vista, EM_DEFAULT, ACT_DEFAULT, "I don't..", "remember..", "a daughter..\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_PROGRESS, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CUTSCENE_TO_GARBAGE, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation intro_02 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "\"I know it's hard,", "I know it's so hard,", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "But I need you", "to remember..\"", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation intro_03 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Cinemint", "presents", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_01 = {
    {0, nullptr, EM_SKIP, ACT_MUSIC_VISKER, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_SKIP, ACT_DEFAULT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_JEREMY, &jeremy_lay_down, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_SULLEN, ACT_DEFAULT, "It body warm.", "", "Ewww.", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, &visker_poke, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_PAIN, ACT_DEFAULT, "Ow, my head..", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_ANGRY, ACT_DEFAULT, "NO, NO LIKE,", "First human down the", "chute in ages,", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_ANGRY, ACT_DEFAULT, "And it ALIVE?", "Hey, do something", "for me, human.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_CONFUSED, ACT_DEFAULT, "..W-What?", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_JEREMY, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "Go and DIE. NOW.", "I'm so so HUNGRY", "for HUMAN.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_ANNOYED, ACT_DEFAULT, "Well, excuse ME.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_SULLEN, ACT_DEFAULT, "*sigh*", "It okay.", "I forgive you.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_SAD, ACT_DEFAULT, "I need to get out", "of here.", "Where's the exit?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_CONFUSED, ACT_DEFAULT, "Why would I say?", "I want you to die", "so I eat you.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "..Okay, I let you", "go but you have to", "do me favor.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "Go to Avalon.", "Send me TURKEY.", "Hungry for turkey.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "Tell them it for", "\"VISKER\".", "\"King of TRASH\".", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_CONFUSED, ACT_DEFAULT, "Uh.. Sure.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_ANGRY, ACT_WALK, "Excuse me, human.", "I wait now..", "for DEAD human.", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, nullptr, {2, 2}},
    {0, nullptr, EM_SKIP, ACT_MUSIC_RESET, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_02 = {
    {0, &sprite_items::db_ch_jeremy, EM_CONFUSED, ACT_DEFAULT, "Hey, you, uh..", "Everything okay?", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_HAPPY, ACT_DEFAULT, "..", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_CONFUSED, ACT_DEFAULT, "Cool.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_02b = {
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "Dead human fall..", "", "Any moment now..", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_03 = {
    {0, &sprite_items::db_ch_visker, EM_SKIP, ACT_TELEPORT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, nullptr, {14, 5}},
    {0, &sprite_items::db_ch_visker, EM_ANGRY, ACT_WALK, "HEY HEY HEY", "Where YOU going?", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, nullptr, {19, 6}},
    {0, &sprite_items::db_ch_jeremy, EM_CONFUSED, ACT_DEFAULT, "Home?", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_SIDE_EYE, ACT_DEFAULT, "But it like,", "SO dangerous.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "..and my", "other options", "are what?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_WAT, ACT_DEFAULT, "Muetos hate humans.", "They ALL want", "you dead.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "..like you?", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "I..", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_SIDE_EYE, ACT_DEFAULT, "..", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_ANNOYED, ACT_WALK, "Human win", "this time.", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, nullptr, {2, 2}},
    {0, nullptr, EM_SKIP, ACT_DEFAULT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_sign01 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "MT. GARBAGE", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "(No Littering)", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_sign01b = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Look, man,", "I'm a sign.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "I only say", "exactly one thing.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Not what you might", "call a", "conversationalist.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_sign02 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "VISKER HOUSE", "NO HUMANS ALLOWED", "UNLESS you DEAD", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation visker_h_01 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "This pile is mostly", "take-away food.", "(He took it away)", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation visker_h_02 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "A pile of tabloids.", "Also Infinite Jest.", "All are dog-eared.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Under the desk..", "Oh dear..", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "You've never seen", "so many", "Reader's Digests.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation visker_h_03 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "His nest is made of", "discarded t-shirts.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Half of them are", "from the exact same", "family reunion.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_sign03 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "TO WHOEVER IS", "PAINTING ALL", "THESE POLKA DOTS", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "PAINT COSTS THE", "CITY MONEY", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "STOP IT", "THANK YOU", "MGMT", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_04 = {
    {0, &sprite_items::db_ch_visker, EM_SAD, ACT_DEFAULT, "So.. Human, uh..", "Close close to", "garbage exit..", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "Human doesn't", "LOOK like fighter", "though.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_SULLEN, ACT_DEFAULT, "Since human is", "gonna fight..", "a lot..", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_HAPPY, ACT_DEFAULT, "I fight human.", "First.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_SIDE_EYE, ACT_DEFAULT, "If human wins,", "then good enough", "to go home.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_EXCITED, ACT_DEFAULT, "If *I* win, then", "I get yummy", "human meal.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "Win-win scenario.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "I'm not really-", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_EXCITED, ACT_DEFAULT, "Yay.", "Let's fight now.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_FIGHT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, FOE_VISKERS_01, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_fight_01 = {
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "You see that?", "That your", "\"THIRD EYE\".", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "It a direct", "window to your soul.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_EXCITED, ACT_DEFAULT, "I so so hungry.", "I go first.", "Mkay?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_fight_02 = {
    {0, &sprite_items::db_ch_visker, EM_DISAPPOINTED, ACT_DEFAULT, "Human is good", "at this.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_SULLEN, ACT_DEFAULT, "But Human is not", "ready for", "NEXT ATTACK.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_fight_03 = {
    {0, &sprite_items::db_ch_visker, EM_ANNOYED, ACT_DEFAULT, "Ow", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_fight_04 = {
    {0, &sprite_items::db_ch_visker, EM_ANNOYED, ACT_DEFAULT, "OW OW OW", "OKAY, HUMAN WIN", "HUMAN WIN", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_05 = {
    {0, &sprite_items::db_ch_visker, EM_DISAPPOINTED, ACT_DEFAULT, "Fine.", "Grrr.", "Human can go.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DEFAULT, ACT_DEFAULT, "But if human", "*dies*..", "Remember..", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_HAPPY, ACT_DEFAULT, "All trash returns", "back to VISKER.", "KING of TRASH.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_05b = {
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Have anything", "else to say?", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_HAPPY, ACT_DEFAULT, "..", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DISAPPOINTED, ACT_DEFAULT, "..Okay, then.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_sign04 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "To escape, you must", "return to where", "you came from.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_sign05 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "ABANDON ALL HOPE,", "YE WHO ENTER", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_06 = {
    {0, &sprite_items::db_ch_jeremy, EM_DISAPPOINTED, ACT_DEFAULT, "Oh boy.", "You again.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker_wife, EM_HAPPY, ACT_DEFAULT, "Huh? Me?", "You not know me,", "human.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DISAPPOINTED, ACT_DEFAULT, "Let me through.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_ANGRY, ACT_WALK, "OI! HUMAN!", "Human don't speak to", "my wife like that!!", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, nullptr, {5, 2}},
    {0, &sprite_items::db_ch_jeremy, EM_WAT, ACT_DEFAULT, "You're.. Oh, I see.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_ANGRY, ACT_DEFAULT, "I now need to fight", "human again for", "wife's honor.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DISAPPOINTED, ACT_DEFAULT, "Ugh..", "I'm never getting", "out of here.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_FIGHT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, FOE_VISKERS_02, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_fight_05 = {
    {0, &sprite_items::db_ch_jeremy, EM_DISAPPOINTED, ACT_DEFAULT, "Look, just get out", "out of the way.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_ANNOYED, ACT_DEFAULT, "LA LA LA", "CAN'T HEAR YOU", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation garbage_06b = {
    {0, nullptr, EM_SKIP, ACT_DEFAULT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_JEREMY, &jeremy_lay_down, {0, 0}},
    {0, nullptr, EM_SKIP, ACT_TELEPORT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_VISKER, nullptr, {5, 2}},
    {0, &sprite_items::db_ch_visker, EM_DISAPPOINTED, ACT_DEFAULT, "Let's go home, wife.", "I'm hungry.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker_wife, EM_DEFAULT, ACT_DEFAULT, "Why not eat human.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_visker, EM_DISAPPOINTED, ACT_DEFAULT, "I'm angry at human.", "We eat human later.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_PROGRESS, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, GARBAGE_TO_BLACK, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_01 = {
    {0, nullptr, EM_SKIP, ACT_DEFAULT, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_JEREMY, &jeremy_lay_down, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_PAIN, ACT_DEFAULT, "Ugh..", "Everything hurts..", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_GINGER, &ginger_eat_lime, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_PAIN, ACT_DEFAULT, "Man, I am TIRED", "of waking up in", "weird places, ugh.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DISAPPOINTED, ACT_DEFAULT, "And why do I smell", "like..", "Limes?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_02 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Surely an empty cot", "would have been", "better than a rug?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_02b = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "You don't really", "feel tired anymore.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_03 = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "The outpost computer", "must have all sorts", "of secrets.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "The password", "being one of them.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_03b = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "If you want to spam", "random passwords,", "be my guest.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_03c = {
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Ok.. Let's try..", "", "\"NBOutpost1972\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "It didn't work.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_03d = {
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Ok.. Let's try..", "", "\"NBOutpost1971\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "It didn't work.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_03e = {
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Ok.. Let's try..", "", "\"NBOutpost1970\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "It didn't work.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_03f = {
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Ok.. Let's try..", "", "\"NBOutpost1969\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "LOGIN SUCCESSFUL", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_WAT, ACT_DEFAULT, "Oh crap", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Uh.. Let's see", "what's on here.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "31-Dec-69", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "FINAL LOG.", "Funding cuts are", "sending us home.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Unfortunately,", "we haven't been", "able to find them.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "In all honesty", "this whole year", "feels like it's been", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "a huge waste.", "", "Our prevailing", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "theory as to where", "new muetos come", "from is that", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "they \"pop out of", "the ground\". It's as", "good as any.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_04 = {
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "You know, once", "I finish my degree,", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "I might be able to", "understand what", "these books mean.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_05 = {
    {0, nullptr, EM_SKIP, ACT_MUSIC_RESET, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "..", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_SKIP, ACT_MUSIC_GINGER, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_HAPPY, ACT_DEFAULT, "Oh! You're awake!", "Thank goodness.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_EMBARRASSED, ACT_DEFAULT, "You're not, like,", "super injured,", "are you?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Did you put", "lime juice on my", "cuts?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "Well yeah,", "it's antiseptic,", "right?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "It stings but it", "is not", "antiseptic.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "Oh.", "", "Uh..", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "", "", "You want a lime?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "..", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Fine.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SIDE_EYE, ACT_DEFAULT, "I found you out", "near the garbage", "chute.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SAD, ACT_DEFAULT, "The rat who lives", "out there usually", "eats dead humans.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "I've been made", "well-aware.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_HAPPY, ACT_DEFAULT, "I'm Ginger,", "by the way.", "", false, SIZE_DEFAULT, SP_DEFAULT, CHAR_GINGER, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_HAPPY, ACT_DEFAULT, "I'm heading to", "Canterbury.", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "I figured that since", "you were a human,", "you were too.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "I really don't want", "to go that far..", "But you're right.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "They won't let me", "back into the city", "without an ID.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_HAPPY, ACT_DEFAULT, "Perfect! You, uh..", "know how to", "get there?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "You're a mueto,", "don't you?", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SIDE_EYE, ACT_DEFAULT, "I guess we'll", "have to figure it", "out, huh?", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "I guess.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_SKIP, ACT_MUSIC_RESET, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_SKIP, ACT_CUE_GINGER, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_06 = {
    {0, &sprite_items::db_ch_ginger, EM_HAPPY, ACT_DEFAULT, "I've been hiding out", "in this old", "outpost lab.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SIDE_EYE, ACT_DEFAULT, "It's nice to have,", "y'know,", "running water.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "Clean bathrooms", "are hard to come by", "out here.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SAD, ACT_DEFAULT, "I'll admit I'm not", "thrilled about", "leaving.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_07 = {
    {0, &sprite_items::db_ch_ginger, EM_WAT, ACT_DEFAULT, "Oh- you don't", "want to open", "the fridge door.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Why not?", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SIDE_EYE, ACT_DEFAULT, "The dehydrated", "limes were the only", "fresh things.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SAD, ACT_DEFAULT, "Everything else..", "Let's just say it", "has a smell.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "This place was", "probably abandoned", "for a year or two.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation lab_08 = {
    {0, &sprite_items::db_ch_jeremy, EM_ANGRY, ACT_DEFAULT, "Ugh!", "They emptied out", "the lockers.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation leaving_lab = {
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "So are you going", "to be following me?", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "Do you not want", "me to?", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "..", "I don't know", "what I want.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Look.", "Today was going", "to be my first", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "day of college.", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_DEFAULT, ACT_DEFAULT, "Oh?", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "I guess I should", "be grateful for", "being alive.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Let's go to", "Canterbury,", "just..", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "I would", "appreciate some", "space.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_ginger, EM_SAD, ACT_DEFAULT, "Right.", "", "Sorry.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, &sprite_items::db_ch_jeremy, EM_DEFAULT, ACT_DEFAULT, "Alright..", "", "Here goes nothing.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_PROGRESS, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, FOREST_01, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

constexpr conversation final_msg = {
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Thanks for", "trying out the", "demo so far!", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "I've only been", "working on this", "for a month,", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "so I'm sure I'll", "make lots of", "progress.", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_DEFAULT, "Discord / X:", "", "\"@cinemint\"", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}},
    {0, nullptr, EM_DEFAULT, ACT_END, "", "", "", false, SIZE_DEFAULT, SP_DEFAULT, 0, nullptr, {0, 0}}};

int action_listener(map_manager *man, character_manager *ch_man);

ge_animations.h: 
#include "ge_text.h"
#include "ge_sprites.h"

// FRAMES   -   SIZE    -   SPEED   -   LOOPS

// Default
const animation anim_walk = {{0, 1, 0, 2}, 4, SP_DEFAULT, true};
const animation anim_stand = {{0}, 1, SP_DEFAULT, false};

// Vista
const animation vista_reminisce = {{9}, 1, SP_DEFAULT, true};
const animation vista_pickup = {{6, 10, 6, 11}, 4, SP_SLOW, false};

// Visker
const animation visker_poke = {{9, 10}, 2, SP_DEFAULT, true};

// Jeremy
const animation jeremy_lay_down = {{9}, 1, SP_DEFAULT, true};

// Ginger
const animation ginger_eat_lime = {{9}, 1, SP_DEFAULT, true};

ge_battle.h: 
// ge_battle.h

#ifndef GE_BATTLE_H
#define GE_BATTLE_H

#include "bn_core.h"
#include "bn_log.h"
#include "bn_regular_bg_item.h"
#include "bn_string.h"
#include "bn_keypad.h"
#include "bn_list.h"
#include "bn_music.h"
#include "bn_music_items.h"
#include "bn_music_items_info.h"
#include "bn_sound_items.h"
#include "bn_math.h"

#include "bn_camera_ptr.h"
#include "bn_regular_bg_items_bg_battle_grid.h"
#include "bn_regular_bg_items_bg_battle_box.h"
#include "bn_regular_bg_items_bg_battle_action.h"
#include "bn_sprite_items_spr_jeremy_01.h"
#include "bn_sprite_items_spr_visker_01.h"
#include "bn_sprite_items_hearts.h"
#include "bn_sprite_items_battle_icons.h"
#include "bn_sprite_items_battle_chars.h"

#include "bn_sprite_items_jeremy_battle_intro.h"
#include "bn_sprite_items_visker_battle_intro.h"

#include "ge_globals.h"
#include "ge_text.h"
#include "ge_bullet.h"

using namespace bn;

enum BATTLE_STAGE
{
    stage_heart_moving,
    stage_main,
    stage_talking,
    stage_recv,
    stage_status,
    stage_attack,
    stage_act // Add new stage for ACT
};

enum BULLET_STYLE
{
    bullet_fall
};

enum STATUS_BAR_BUTTONS
{
    STATUS_BAR_NONE,
    STATUS_BAR_ATTACK,
    STATUS_BAR_ACT,
    STATUS_BAR_ITEM,
    STATUS_BAR_SPARE,
    STATUS_BAR_DEFEND,
    STATUS_BAR_SIZE
};

enum BATTLE_RESULT
{
    RESULT_FIRST,
    RESULT_UP,
    RESULT_DOWN,
    RESULT_SPARE,
    RESULT_ACT, // Add new result type for ACT actions
    RESULT_LAST_WIN,
    RESULT_LAST_LOSE,
    RESULT_SIZE
};

// Structure to hold action data
struct battle_action
{
    const char *name;
    conversation *convo;
    bool used;

    battle_action(const char *n, conversation *c) : name(n), convo(c), used(false) {}
};

struct attack_unit_dissolve
{
    optional<sprite_ptr> spr;
};

struct attack_bar
{
    optional<sprite_ptr> header;
    optional<sprite_ptr> recv_bar;
    optional<sprite_ptr> unit;
    vector<attack_unit_dissolve, 5> dissolves;
    bool is_ended = false;

    attack_bar(int y_delta, int index);
    void update();
};

struct attack
{
    vector<attack_bar, 3> attack_bars;
    bool is_ended = false;

    attack();
    void update();
};

struct status_bar_items
{
    optional<text> icon_label;
    int index = 0;

    status_bar_items();

    void update_label();
    void update();
};

// New struct for ACT menu
struct status_bar_act
{
    optional<text> icon_labels[4];
    int index = 0;
    int action_count = 0;
    battle_action *actions[4]; // Pointers to available actions

    status_bar_act();
    void init();
    void update_labels();
    void update();
};

struct status_bar_menu
{
    optional<sprite_ptr> battle_icons[5];
    optional<text> icon_label;
    int index = 0;

    status_bar_menu();

    void update_label();
    void update();
};

struct status_bar
{
    optional<sprite_ptr> char_img;
    optional<text> name;
    optional<text> hp;
    regular_bg_ptr action_bg = regular_bg_items::bg_battle_action.create_bg(0, 0);
    int actor_index;

    static int current_party_size;
    static int current_enemy_size;
    static int selected_menu;
    static vector<battle_action, 4> available_actions; // Pointer to the available actions

    optional<status_bar_menu> sb_menu;
    optional<status_bar_items> sb_items;
    optional<status_bar_act> sb_act;

    status_bar(int actor_index_ = 0);
    void update();
};

struct recv
{
    int ticker = 0;
    vector<bullet, bullet_count> bullets;
    int bullet_style = bullet_fall;
    regular_bg_ptr bg_action = regular_bg_items::bg_battle_box.create_bg(0, 0);
    vector_2 eye_pos = {0, 0};
    unsigned int random_value = 32;
    sprite_ptr heart = sprite_items::hearts.create_sprite(
        0,
        0,
        1);

    recv();
    void update(int &g_defense_stacks);
    void spawn_bullets();
};

vector_2 moveTowards(vector_2 from, vector_2 towards, fixed_t<4> speed);
int battle_map();

#endif

ge_bullet.h: 
// ge_bullet.h - Memory-optimized version
#ifndef GE_BULLET_H
#define GE_BULLET_H

#include "bn_vector.h"
#include "bn_optional.h"
#include "bn_sprite_ptr.h"
#include "bn_fixed_point.h"

#define bullet_count 16

enum BULLET_ANIM_TYPES : uint8_t
{
    BULLET_FALL,
    BULLET_RISE,
    BULLET_ZIGZAG,
    BULLET_WAVE,
    BULLET_ACCEL,
    BULLET_BOUNCE,
    BULLET_HOMING,
    BULLET_ORBIT,
    BULLET_SPIRAL,
    BULLET_SIZE
};

// Shared pattern data - ONE copy for all bullets of same type
struct bullet_pattern
{
    int8_t vx_base;    // Base velocity * 16 (store as int8)
    int8_t vy_base;    // Base velocity * 16
    uint8_t amplitude; // 0-255 range
    uint8_t period;    // 0-255 frames
    int8_t accel;      // Acceleration * 128
    uint8_t flags;     // Bit flags for behavior
};

// Pre-computed patterns (stored in ROM, no RAM usage)
extern const bullet_pattern PATTERNS[BULLET_SIZE];

// Compact bullet struct - only 8 bytes + sprite pointer!
struct bullet
{
    bn::optional<bn::sprite_ptr> item;
    
    // Only 8 bytes of state data using union
    union {
        struct {
            int16_t x;        // Position * 4 (gives us -8192 to 8191 range)
            int16_t y;        // Position * 4
            uint8_t ticker;   // 0-255 frames
            uint8_t type;     // Animation type
            int8_t state1;    // Generic state (zig direction, orbit angle, etc.)
            int8_t state2;    // Generic state (speed modifier, radius, etc.)
        } compact;
        
        // Alternative view for patterns that need it
        struct {
            int16_t x;
            int16_t y;
            uint16_t ticker_and_type; // Combined ticker (lower 8) and type (upper 8)
            int16_t velocity;          // Combined vx/vy for some patterns
        } alt;
    };
    
    bullet(int16_t x_pos, int16_t y_pos, uint8_t anim_type);
    void update();
    static void populate(bn::vector<bullet, bullet_count>* bullets, int anim_type);
    
    // Helper to get actual position
    bn::fixed get_x() const { return bn::fixed(compact.x) / 4; }
    bn::fixed get_y() const { return bn::fixed(compact.y) / 4; }
    void set_pos(bn::fixed x, bn::fixed y) {
        compact.x = (x * 4).integer();
        compact.y = (y * 4).integer();
    }
};

// Global lookup tables (stored in ROM, shared by all bullets)
extern const int8_t SINE_TABLE[64];  // Pre-computed sine wave values

#endif

ge_character_manager.h: 
// ge_character_manager.h

#ifndef GE_CHARACTER_MANAGER_H
#define GE_CHARACTER_MANAGER_H

#include "bn_list.h"
#include "bn_unique_ptr.h"
#include "bn_optional.h"
#include "ge_sprites.h"
#include "ge_text.h"
#include "main.h"

struct character_manager
{
    list<unique_ptr<character>, 32> characters;
    character *player_ptr;
    optional<dialogue_box> db;
    int status = CONTINUE;

    character_manager();

    character *add_character(int index, vector_2 position);
    bool remove_character(character *ch);
    void clear_npcs();
    character *get_player() { return player_ptr; }
    character *find_at_position(vector_2 pos, int tolerance = 32);
    character *find_by_index(int index);
    void update(map_manager *current_map);
    void alert();
    int size() const { return characters.size(); }

    template <typename Func>
    void for_each(Func func)
    {
        for (auto &ch : characters)
        {
            if (ch)
            {
                func(ch.get());
            }
        }
    }
};

#endif // GE_CHARACTER_MANAGER_H

ge_globals.h: 
// ge_globals.h

#ifndef GE_GLOBALS_H
#define GE_GLOBALS_H

#include "bn_music_item.h"
#include "bn_random.h"
#include "ge_maps.h"
#include "ge_sprites.h"

using namespace bn;

constexpr int GE_PARTY_SIZE = 4;

enum action_list
{
	ACT_NONE,
	CONVO_SCENE_1,
	CONVO_GARBAGE_1,
	CONVO_GARBAGE_2,
	CONVO_GARBAGE_3,
	TO_GARBAGE_02,
	CONVO_GARBAGE_SIGN01,
	TO_VISKERS_HOUSE,
	TO_GARBAGE_03,
	TO_GARBAGE_02b,
	CONVO_VISKER_SIGN,
	CONVO_VISKER_BED,
	CONVO_VISKER_NIGHTSTAND,
	CONVO_VISKER_FOOD,
	CONVO_GARBAGE_03_SIGN,
	CONVO_VISKER_FIGHT,
	CONVO_VISKER_AFTER_FIGHT,
	TO_GARBAGE_04,
	GARBAGE_04_EXIT_01,
	GARBAGE_04_EXIT_02,
	GARBAGE_04_EXIT_03,
	GARBAGE_04_EXIT_04,
	GARBAGE_04_EXIT_05,
	CONVO_GARBAGE_04_SIGN,
	EXIT_GARBAGE_01,
	CONVO_GARBAGE_05_SIGN,
	CONVO_GARBAGE_FINAL_01,
	CONVO_LAB_RUG,
	LAB_BED,
	LAB_COMPUTER,
	LAB_BOOKSHELF,
	CONVO_LAB_GINGER,
	LAB_DOOR,
	LAB_FRIDGE,
	LAB_LOCKER,
	TO_LAB_OUTSIDE,
	ACTIONS_SIZE,
	ENTER_BG = 49,
	EXIT_BG = 50
};

enum response_list
{
	NONE,
	RESPONSES_SIZE
};

struct global_data
{
	random bn_random;
	int action_iterations[ACTIONS_SIZE] = {0};
	const map *entry_map = nullptr;
	const regular_bg_item *bg = nullptr;
	vector_2 entry_position = {0, 0};
	vector_2 entry_position_raw = {0, 0};
	int entry_direction = DIR_RIGHT;
	int battle_foe = 0;
	int hp[4] = {20, 20, 20, 20};
	int max_hp[4] = {20, 20, 20, 20};
	int enemy_hp[4] = {20, 20, 20, 20};
	int enemy_max_hp[4] = {20, 20, 20, 20};
	int enemy_allowed_moveset = 2;
	bool progress_cue = false;
	int process_stage = 0;

	const music_item *bg_track;
};

// Declaration only - use 'extern' keyword
extern global_data *global_data_ptr;

#endif // GE_GLOBALS_H

ge_maps.h: 
// ge_maps.h

#ifndef GE_MAPS_H
#define GE_MAPS_H

#include "bn_regular_bg_ptr.h"
#include "bn_regular_bg_item.h"
#include "bn_sound_item.h"
#include "bn_array.h"
#include "bn_optional.h"

#include "ge_structs.h"

// Floors
#include "bn_regular_bg_items_floor_wood01.h"

// Using bn namespace types
using bn::array;
using bn::regular_bg_item;
using bn::sound_item;

struct map
{
  vector_2 size;
  vector_2 raw_size;
  array<int, 2048> collisions;
  array<int, 2048> actions;
  array<int, 2048> characters;
  const regular_bg_item *bg_item_ptr;

  // Constexpr constructor for compile-time initialization
  constexpr map(vector_2 size_,
                vector_2 raw_size_,
                const array<int, 2048> &collisions_,
                const array<int, 2048> &actions_,
                const array<int, 2048> &characters_,
                const regular_bg_item *bg_item_ptr_)
      : size(size_),
        raw_size(raw_size_),
        collisions(collisions_),
        actions(actions_),
        characters(characters_),
        bg_item_ptr(bg_item_ptr_) {}
};

struct map_manager
{
  optional<regular_bg_ptr> bg_ptr;
  optional<regular_bg_ptr> collider_ptr;
  const map *current_map;

  map_manager(const map *current_map_);

  void update();
  int collision(vector_2 location);
  bool check_box_collision(bound box);
  int action(vector_2 location); // Added this declaration
};

#endif

ge_map_data.h: 
// Auto-Generated Map Header
// This file contains extern declarations for all generated maps

#ifndef GE_MAP_DATA_H
#define GE_MAP_DATA_H

#include "ge_maps.h"

inline constexpr map map_forest_01;
inline constexpr map map_garbage_01;
inline constexpr map map_garbage_02;
inline constexpr map map_garbage_03;
inline constexpr map map_garbage_04;
inline constexpr map map_garbage_05;
inline constexpr map map_lab_01;
inline constexpr map map_room01;
inline constexpr map map_viskers_house;

#endif // GE_MAP_DATA_H


ge_sprites.h: 
#ifndef GE_SPRITES_H
#define GE_SPRITES_H

#include "bn_core.h"
#include "bn_array.h"
#include "bn_sprites.h"
#include "bn_sprite_item.h"
#include "bn_sprite_ptr.h"
#include "bn_optional.h"
#include "bn_vector.h"
#include "bn_keypad.h"
#include "bn_list.h"

#include "ge_structs.h"
#include "ge_maps.h"

using namespace bn;

bool within_bounds(bound me, bound you);

struct animation
{
    array<int, 64> frames = {0};
    int size = 0;
    int speed = 1;
    bool loop = true;
};

struct v_sprite_ptr
{
    static vector<v_sprite_ptr *, 12> manager;
    static vector_2 camera;

    const sprite_item *sprite_item_ptr;
    optional<sprite_ptr> sprite_ptr_raw[2];
    bound bounds;
    int frame;

    v_sprite_ptr();
    v_sprite_ptr(const sprite_item *sprite_item_ptr_, vector_2 position = {0, 0}, int width = 32, int height = 32, int frame_ = 0);
    ~v_sprite_ptr();

    void move(vector_2 direction);
    bound real_position() const;
    void set_frame(int frame_);
    static void update(bool character_box_ended);

    static void clear_all()
    {
        for (auto *item : manager)
        {
            if (item->sprite_ptr_raw[0].has_value())
                item->sprite_ptr_raw[0].reset();
            if (item->sprite_ptr_raw[1].has_value())
                item->sprite_ptr_raw[1].reset();
        }
        manager.clear();
    }
};

enum character_list
{
    CHAR_DEFAULT,
    CHAR_VISTA,
    CHAR_JEREMY,
    CHAR_VISKER,
    CHAR_VISKER_WIFE,
    CHAR_GINGER,
    CHAR_TYPEWRITER
};

enum facing
{
    DIR_UP,
    DIR_DOWN,
    DIR_LEFT,
    DIR_RIGHT
};

enum character_type
{
    CH_TYPE_PLAYER,
    CH_TYPE_NPC,
    CH_TYPE_PUSHABLE,
    CH_TYPE_ITEM,
    CH_TYPE_DECORATION,
    CH_TYPE_DECORATION_ABOVE
};

struct character
{
    v_sprite_ptr v_sprite;
    const animation *current_animation;
    const animation *idle_animation;

    int index = CHAR_VISTA;
    int ticker = 0;
    int frame = 0;
    int face = DIR_DOWN;

    vector_2 move_to = {0, 0};
    bool is_follow = false;
    int follow_id = CHAR_JEREMY;

    character(int index_, vector_2 start_);

    void update(map_manager *current_map, bool character_box_ended);

    static void add(list<character, 32> *characters, int character_id, vector_2 location);

    int type()
    {
        switch (index)
        {
        case CHAR_VISTA:
            return CH_TYPE_PLAYER;
        case CHAR_JEREMY:
            return CH_TYPE_PLAYER;
        default:
            return CH_TYPE_NPC;
        }
    }
};

#endif // GE_SPRITES_H

ge_structs.h: 
#ifndef GE_STRUCTS_H
#define GE_STRUCTS_H

#include "bn_fixed.h"

using namespace bn;

constexpr int screen_width = 240;
constexpr int screen_height = 160;

struct vector_2
{
    fixed_t<4> x = 0;
    fixed_t<4> y = 0;
};

struct bound
{
    vector_2 position;
    fixed_t<4> width;
    fixed_t<4> height;
    
    // Default constructor
    constexpr bound() : position(0, 0), width(0), height(0) {}
    
    // Constructor for initialization
    constexpr bound(vector_2 pos, fixed_t<4> w, fixed_t<4> h) 
        : position(pos), width(w), height(h) {}
};

const bound screen = {{0, 0}, screen_width, screen_height};

#endif // GE_STRUCTS_H

ge_text.h: 
// ge_text.h

#ifndef GE_TEXT_H
#define GE_TEXT_H

#include "bn_vector.h"
#include "bn_string.h"
#include "bn_sprite_ptr.h"
#include "bn_regular_bg_ptr.h"

#include "ge_structs.h"
#include "ge_sprites.h"

// Forward declaration to avoid circular dependency
struct character_manager;

using namespace bn;

enum progress
{
    CUTSCENE_01,
    CUTSCENE_02,
    CUTSCENE_TO_GARBAGE,
    GARBAGE_TO_BLACK,
    BLACK_TO_LAB,
    FOREST_01,
    FINAL_MSG
};

enum foes
{
    FOE_VISKERS_01,
    FOE_VISKERS_02
};

enum actions
{
    ACT_DEFAULT,
    ACT_EMOTE,
    ACT_TURN,
    ACT_WALK,
    ACT_TELEPORT,
    ACT_SPAWN,
    ACT_MULTIPLE_CHOICE,
    ACT_END,
    ACT_FIGHT,
    ACT_PROGRESS,
    ACT_CUE_GINGER,
    ACT_SFX_KNOCK,
    ACT_MUSIC_VISKER,
    ACT_MUSIC_GINGER,
    ACT_MUSIC_FADEOUT,
    ACT_MUSIC_RESET
};

enum speed
{
    SP_DEFAULT,
    SP_SLOW,
    SP_FAST,
    SP_SHAKE
};

enum emotion
{
    EM_DEFAULT,
    EM_HAPPY,
    EM_EXCITED,
    EM_ANGRY,
    EM_SAD,
    EM_DISAPPOINTED,
    EM_SULLEN,
    EM_SIDE_EYE,
    EM_LAUGH,
    EM_EMBARRASSED,
    EM_ANNOYED,
    EM_WAT,
    EM_CONFUSED,
    EM_PAIN,
    EM_SKIP,
};

enum size
{
    SIZE_DEFAULT,
    SIZE_SMALL,
    SIZE_LARGE
};

struct letter
{
    optional<sprite_ptr> sprite;
    vector_2 ideal_position;
    vector_2 temp_position;
    int char_index;

    letter(char ch, vector_2 ideal_position_);

    void update(bool shake, int size);
};

// Forward declare toast before text
struct toast;

struct text
{
    vector<letter, 20> letters;
    vector_2 start;
    int index = 0;
    int current_x = 0;
    bool active = false;
    string<20> reference;
    int size = SIZE_DEFAULT;

    static vector<toast, 16> toasts;
    static void add_toast(string<20> value, vector_2 pos);
    static void add_toast(int value, vector_2 pos);
    static void update_toasts();
    static bool at_location(vector_2 pos);

    text();
    text(vector_2 start_ = {0, 0});
    text(const char *value = nullptr, vector_2 start_ = {0, 0});
    text(const string<20> &value, vector_2 start_ = {0, 0});

    void init(const char *value);
    void init(const string<20> &value);
    void update(const sprite_item *portrait, bool typewriter);
    void render();
    void set_position(int x, int y);
    bool is_ended();
};

char digit_conv(int digit);

struct toast
{
    text value = {nullptr, {0, 0}};
    int ticker;

    toast();
};

struct dialogue_line
{
    int id = 0;
    const sprite_item *portrait = nullptr;
    int emotion = EM_DEFAULT;
    int action = ACT_DEFAULT;
    const char *raw_text[3] = {nullptr, nullptr, nullptr};

    int branches[3] = {0, 0, 0};
    bool shake = false;
    int size = SIZE_DEFAULT;
    int speed = SP_DEFAULT;

    int index = 0;
    const animation *anim = nullptr;
    vector_2 navigate = {0, 0};

    constexpr dialogue_line(
        int id_ = 0,
        const sprite_item *char_ = nullptr,
        int emotion_ = EM_DEFAULT,
        int action_ = ACT_DEFAULT,
        const char *line1 = nullptr,
        const char *line2 = nullptr,
        const char *line3 = nullptr,
        bool shake_ = false,
        int size_ = SIZE_DEFAULT,
        int speed_ = SP_DEFAULT,
        int index_ = 0,
        const animation *anim_ = nullptr,
        vector_2 navigate_ = {0, 0}) : id(id_),
                                       portrait(char_),
                                       emotion(emotion_),
                                       action(action_),
                                       raw_text{line1, line2, line3},
                                       shake(shake_),
                                       size(size_),
                                       speed(speed_),
                                       index(index_),
                                       anim(anim_),
                                       navigate(navigate_)
    {
    }
};

typedef const dialogue_line conversation[128];

struct dialogue_box
{
    optional<sprite_ptr> portrait;
    optional<regular_bg_ptr> box;
    optional<sprite_ptr> pointer;
    int ticker;
    conversation *active_conversation;
    int index;
    int size;
    text lines[3] = {
        {nullptr, {-40, 32}},
        {nullptr, {-40, 48}},
        {nullptr, {-40, 64}}};

    dialogue_box();
    void load(conversation *new_conversation);
    void init(character_manager *ch_man);
    void update();
    bool is_ended();

    bool is_text_complete();                               // Check if current text is fully displayed
    void instant_complete_text();                          // Instantly complete current text
    void handle_a_button_press(character_manager *ch_man); // Handle A button input
    void advance(character_manager *ch_man);               // Advance to next dialogue
};

#endif // GE_TEXT_H

main.h: 
// main.h

#ifndef MAIN_H
#define MAIN_H

enum RETURN_TYPE {
    CONTINUE,
    NEW_MAP,
    NEW_CHAPTER,
    BATTLE
};

#endif